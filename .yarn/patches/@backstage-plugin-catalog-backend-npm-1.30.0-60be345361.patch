diff --git a/dist/service/createRouter.cjs.js b/dist/service/createRouter.cjs.js
index 7a05aa7651d11fb42d5d8b4b0bae33e77fe7788e..10327a4fa367957d064ab6c88f83b9f9378325d9 100644
--- a/dist/service/createRouter.cjs.js
+++ b/dist/service/createRouter.cjs.js
@@ -18,6 +18,7 @@ var parseEntityPaginationParams = require('./request/parseEntityPaginationParams
 var AuthorizedValidationService = require('./AuthorizedValidationService.cjs.js');
 var write = require('./response/write.cjs.js');
 var createEntityArrayJsonStream = require('./response/createEntityArrayJsonStream.cjs.js');
+var backstagePluginAuditLogNode = require('@janus-idp/backstage-plugin-audit-log-node');
 
 function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }
 
@@ -45,6 +46,11 @@ async function createRouter(options) {
     httpAuth,
     disableRelationsCompatibility = false
   } = options;
+  const auditLogger = new backstagePluginAuditLogNode.DefaultAuditLogger({
+    logger,
+    authService: auth,
+    httpAuthService: httpAuth
+  });
   const readonlyEnabled = config.getOptionalBoolean("catalog.readonly") || false;
   if (readonlyEnabled) {
     logger.info("Catalog is running in readonly mode");
@@ -52,12 +58,61 @@ async function createRouter(options) {
   if (refreshService) {
     router$1.post("/refresh", async (req, res) => {
       const { authorizationToken, ...restBody } = req.body;
-      const credentials = authorizationToken ? await auth.authenticate(authorizationToken) : await httpAuth.credentials(req);
-      await refreshService.refresh({
-        ...restBody,
-        credentials
-      });
-      res.status(200).end();
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityRefresh",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          metadata: {
+            entityRef: restBody.entityRef
+          },
+          request: req,
+          message: `Refresh attempt for ${restBody.entityRef} initiated by ${actorId}`
+        });
+        const credentials = authorizationToken ? await auth.authenticate(authorizationToken) : await httpAuth.credentials(req);
+        await refreshService.refresh({
+          ...restBody,
+          credentials
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityRefresh",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          metadata: {
+            entityRef: restBody.entityRef
+          },
+          response: {
+            status: 200
+          },
+          request: req,
+          message: `Refresh attempt for ${restBody.entityRef} triggered by ${actorId}`
+        });
+        res.status(200).end();
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityRefresh",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          metadata: {
+            entityRef: restBody.entityRef
+          },
+          request: req,
+          message: `Refresh attempt for ${restBody.entityRef} by ${actorId} failed`
+        });
+        throw err;
+      }
     });
   }
   if (permissionIntegrationRouter) {
@@ -65,262 +120,1030 @@ async function createRouter(options) {
   }
   if (entitiesCatalog) {
     router$1.get("/entities", async (req, res) => {
-      const filter = parseEntityFilterParams.parseEntityFilterParams(req.query);
-      const fields = parseEntityTransformParams.parseEntityTransformParams(req.query);
-      const order = parseEntityOrderParams.parseEntityOrderParams(req.query);
-      const pagination = parseEntityPaginationParams.parseEntityPaginationParams(req.query);
-      const credentials = await httpAuth.credentials(req);
-      if (pagination || disableRelationsCompatibility !== true) {
-        const { entities, pageInfo } = await entitiesCatalog.entities({
-          filter,
-          fields,
-          order,
-          pagination,
-          credentials
+      const actorId = await auditLogger.getActorId(
+        req
+      );
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetch",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          message: `Entity fetch attempt initiated by ${actorId}`
         });
-        if (pageInfo.hasNextPage) {
-          const url = new URL(`http://ignored${req.url}`);
-          url.searchParams.delete("offset");
-          url.searchParams.set("after", pageInfo.endCursor);
-          res.setHeader("link", `<${url.pathname}${url.search}>; rel="next"`);
+        const filter = parseEntityFilterParams.parseEntityFilterParams(req.query);
+        const fields = parseEntityTransformParams.parseEntityTransformParams(req.query);
+        const order = parseEntityOrderParams.parseEntityOrderParams(req.query);
+        const pagination = parseEntityPaginationParams.parseEntityPaginationParams(req.query);
+        const credentials = await httpAuth.credentials(req);
+        if (pagination || disableRelationsCompatibility !== true) {
+          const { entities, pageInfo } = await entitiesCatalog.entities({
+            filter,
+            fields,
+            order,
+            pagination,
+            credentials
+          });
+          if (pageInfo.hasNextPage) {
+            const url = new URL(`http://ignored${req.url}`);
+            url.searchParams.delete("offset");
+            url.searchParams.set("after", pageInfo.endCursor);
+            res.setHeader(
+              "link",
+              `<${url.pathname}${url.search}>; rel="next"`
+            );
+          }
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityFetch",
+            actorId,
+            status: "succeeded",
+            stage: "completion",
+            request: req,
+            // Let's not log out the entities since this can make the log very big due to it not being paged?
+            response: {
+              status: 200
+            },
+            message: `Entity fetch attempt by ${actorId} succeeded`
+          });
+          await write.writeEntitiesResponse({
+            res,
+            items: entities,
+            alwaysUseObjectMode: !disableRelationsCompatibility
+          });
+          return;
         }
-        await write.writeEntitiesResponse({
-          res,
-          items: entities,
-          alwaysUseObjectMode: !disableRelationsCompatibility
+        const responseStream = createEntityArrayJsonStream.createEntityArrayJsonStream(res);
+        const limit = 1e4;
+        let cursor;
+        try {
+          let currentWrite = void 0;
+          do {
+            const result = await entitiesCatalog.queryEntities(
+              !cursor ? {
+                credentials,
+                fields,
+                limit,
+                filter,
+                orderFields: order,
+                skipTotalItems: true
+              } : { credentials, fields, limit, cursor }
+            );
+            if (await currentWrite) {
+              return;
+            }
+            if (result.items.entities.length) {
+              currentWrite = responseStream.send(result.items);
+            }
+            cursor = result.pageInfo?.nextCursor;
+          } while (cursor);
+          await currentWrite;
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityFetch",
+            actorId,
+            status: "succeeded",
+            stage: "completion",
+            request: req,
+            // Let's not log out the entities since this can make the log very big due to it not being paged?
+            response: {
+              status: 200
+            },
+            message: `Entity fetch attempt by ${actorId} succeeded`
+          });
+          responseStream.complete();
+        } finally {
+          responseStream.close();
+        }
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetch",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Entity fetch attempt by ${actorId} failed`
         });
-        return;
-      }
-      const responseStream = createEntityArrayJsonStream.createEntityArrayJsonStream(res);
-      const limit = 1e4;
-      let cursor;
-      try {
-        let currentWrite = void 0;
-        do {
-          const result = await entitiesCatalog.queryEntities(
-            !cursor ? {
-              credentials,
-              fields,
-              limit,
-              filter,
-              orderFields: order,
-              skipTotalItems: true
-            } : { credentials, fields, limit, cursor }
-          );
-          if (await currentWrite) {
-            return;
-          }
-          if (result.items.entities.length) {
-            currentWrite = responseStream.send(result.items);
-          }
-          cursor = result.pageInfo?.nextCursor;
-        } while (cursor);
-        await currentWrite;
-        responseStream.complete();
-      } finally {
-        responseStream.close();
+        throw err;
       }
     }).get("/entities/by-query", async (req, res) => {
-      const { items, pageInfo, totalItems } = await entitiesCatalog.queryEntities({
-        limit: req.query.limit,
-        offset: req.query.offset,
-        ...parseQueryEntitiesParams.parseQueryEntitiesParams(req.query),
-        credentials: await httpAuth.credentials(req)
-      });
-      await write.writeEntitiesResponse({
-        res,
-        items,
-        alwaysUseObjectMode: !disableRelationsCompatibility,
-        responseWrapper: (entities) => ({
-          items: entities,
-          totalItems,
-          pageInfo: {
-            ...pageInfo.nextCursor && {
-              nextCursor: util.encodeCursor(pageInfo.nextCursor)
-            },
-            ...pageInfo.prevCursor && {
-              prevCursor: util.encodeCursor(pageInfo.prevCursor)
+      const actorId = await auditLogger.getActorId(
+        req
+      );
+      try {
+        await auditLogger.auditLog({
+          eventName: "QueriedCatalogEntityFetch",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          message: `Queried entity fetch attempt initiated by ${actorId}`
+        });
+        const { items, pageInfo, totalItems } = await entitiesCatalog.queryEntities({
+          limit: req.query.limit,
+          offset: req.query.offset,
+          ...parseQueryEntitiesParams.parseQueryEntitiesParams(req.query),
+          credentials: await httpAuth.credentials(req)
+        });
+        await auditLogger.auditLog({
+          eventName: "QueriedCatalogEntityFetch",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            totalEntities: totalItems,
+            pageInfo: {
+              ...pageInfo.nextCursor && {
+                nextCursor: util.encodeCursor(pageInfo.nextCursor)
+              },
+              ...pageInfo.prevCursor && {
+                prevCursor: util.encodeCursor(pageInfo.prevCursor)
+              }
             }
-          }
-        })
-      });
+          },
+          // Let's not log out the entities since this can make the log very big
+          response: {
+            status: 200
+          },
+          message: `Queried entity fetch attempt by ${actorId} succeeded`
+        });
+        await write.writeEntitiesResponse({
+          res,
+          items,
+          alwaysUseObjectMode: !disableRelationsCompatibility,
+          responseWrapper: (entities) => ({
+            items: entities,
+            totalItems,
+            pageInfo: {
+              ...pageInfo.nextCursor && {
+                nextCursor: util.encodeCursor(pageInfo.nextCursor)
+              },
+              ...pageInfo.prevCursor && {
+                prevCursor: util.encodeCursor(pageInfo.prevCursor)
+              }
+            }
+          })
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "QueriedCatalogEntityFetch",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Queried entity fetch attempt by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get("/entities/by-uid/:uid", async (req, res) => {
       const { uid } = req.params;
-      const { entities } = await entitiesCatalog.entities({
-        filter: basicEntityFilter.basicEntityFilter({ "metadata.uid": uid }),
-        credentials: await httpAuth.credentials(req)
-      });
-      write.writeSingleEntityResponse(res, entities, `No entity with uid ${uid}`);
+      const actorId = await auditLogger.getActorId(req);
+      let entityRef;
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByUid",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          metadata: {
+            uid
+          },
+          message: `Fetch attempt for entity with uid ${uid} initiated by ${actorId}`
+        });
+        const { entities } = await entitiesCatalog.entities({
+          filter: basicEntityFilter.basicEntityFilter({ "metadata.uid": uid }),
+          credentials: await httpAuth.credentials(req)
+        });
+        if (entities.entities.length) {
+          entityRef = entities.type === "object" ? catalogModel.stringifyEntityRef(entities.entities[0]) : entities.entities[0];
+        }
+        write.writeSingleEntityResponse(res, entities, `No entity with uid ${uid}`);
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByUid",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            uid,
+            entityRef
+          },
+          response: {
+            status: 200
+          },
+          message: `Fetch attempt for entity with uid ${uid} by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByUid",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          metadata: {
+            uid
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Fetch attempt for entity with uid ${uid} by ${actorId} failed`
+        });
+        throw err;
+      }
     }).delete("/entities/by-uid/:uid", async (req, res) => {
       const { uid } = req.params;
-      await entitiesCatalog.removeEntityByUid(uid, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(204).end();
+      const actorId = await auditLogger.getActorId(req);
+      let entityRef;
+      try {
+        const { entities } = await entitiesCatalog.entities({
+          filter: basicEntityFilter.basicEntityFilter({ "metadata.uid": uid }),
+          credentials: await httpAuth.credentials(req)
+        });
+        if (entities.entities.length) {
+          entityRef = entities.type === "object" ? catalogModel.stringifyEntityRef(entities.entities[0]) : entities.entities[0];
+        }
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityDeletion",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          metadata: {
+            uid,
+            entityRef
+          },
+          message: `Deletion attempt for entity with uid ${uid} initiated by ${actorId}`
+        });
+        await entitiesCatalog.removeEntityByUid(uid, {
+          credentials: await httpAuth.credentials(req)
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityDeletion",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            uid,
+            entityRef
+          },
+          response: {
+            status: 204
+          },
+          message: `Deletion attempt for entity with uid ${uid} by ${actorId} succeeded`
+        });
+        res.status(204).end();
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityDeletion",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Deletion attempt for entity with uid ${uid} by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get("/entities/by-name/:kind/:namespace/:name", async (req, res) => {
       const { kind, namespace, name } = req.params;
-      const { items } = await entitiesCatalog.entitiesBatch({
-        entityRefs: [catalogModel.stringifyEntityRef({ kind, namespace, name })],
-        credentials: await httpAuth.credentials(req)
-      });
-      write.writeSingleEntityResponse(
-        res,
-        items,
-        `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`
-      );
+      const entityRef = catalogModel.stringifyEntityRef({ kind, namespace, name });
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByName",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          metadata: {
+            entityRef
+          },
+          message: `Fetch attempt for entity with entityRef ${entityRef} initiated by ${actorId}`
+        });
+        const { items } = await entitiesCatalog.entitiesBatch({
+          entityRefs: [catalogModel.stringifyEntityRef({ kind, namespace, name })],
+          credentials: await httpAuth.credentials(req)
+        });
+        write.writeSingleEntityResponse(
+          res,
+          items,
+          `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`
+        );
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByName",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            entityRef
+          },
+          response: {
+            status: 200
+          },
+          message: `Fetch attempt for entity with entityRef ${entityRef} by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByName",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          metadata: {
+            entityRef
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Fetch attempt for entity with entityRef ${entityRef} by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get(
       "/entities/by-name/:kind/:namespace/:name/ancestry",
       async (req, res) => {
         const { kind, namespace, name } = req.params;
         const entityRef = catalogModel.stringifyEntityRef({ kind, namespace, name });
-        const response = await entitiesCatalog.entityAncestry(entityRef, {
+        const actorId = await auditLogger.getActorId(req);
+        try {
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityAncestryFetch",
+            actorId,
+            status: "succeeded",
+            stage: "initiation",
+            request: req,
+            metadata: {
+              entityRef
+            },
+            message: `Fetch attempt for entity ancestor of entity ${entityRef} initiated by ${actorId}`
+          });
+          const response = await entitiesCatalog.entityAncestry(entityRef, {
+            credentials: await httpAuth.credentials(req)
+          });
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityAncestryFetch",
+            actorId,
+            status: "succeeded",
+            stage: "completion",
+            request: req,
+            metadata: {
+              rootEntityRef: response.rootEntityRef,
+              ancestry: response.items.map((ancestryLink) => {
+                return {
+                  entityRef: catalogModel.stringifyEntityRef(ancestryLink.entity),
+                  parentEntityRefs: ancestryLink.parentEntityRefs
+                };
+              })
+            },
+            response: {
+              status: 200
+            },
+            message: `Fetch attempt for entity ancestor of entity ${entityRef} by ${actorId} succeeded`
+          });
+          res.status(200).json(response);
+        } catch (err) {
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityAncestryFetch",
+            actorId,
+            status: "failed",
+            stage: "completion",
+            level: "error",
+            request: req,
+            metadata: {
+              entityRef
+            },
+            errors: [
+              {
+                name: err.name,
+                message: err.message,
+                stack: err.stack
+              }
+            ],
+            message: `Fetch attempt for entity ancestor of entity ${entityRef} by ${actorId} failed`
+          });
+          throw err;
+        }
+      }
+    ).post("/entities/by-refs", async (req, res) => {
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityBatchFetch",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          message: `Batch entity fetch attempt initiated by ${actorId}`
+        });
+        const request = entitiesBatchRequest.entitiesBatchRequest(req);
+        const { items } = await entitiesCatalog.entitiesBatch({
+          entityRefs: request.entityRefs,
+          filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
+          fields: parseEntityTransformParams.parseEntityTransformParams(req.query, request.fields),
           credentials: await httpAuth.credentials(req)
         });
-        res.status(200).json(response);
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityBatchFetch",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            ...request
+          },
+          response: {
+            status: 200
+          },
+          message: `Batch entity fetch attempt by ${actorId} succeeded`
+        });
+        await write.writeEntitiesResponse({
+          res,
+          items,
+          alwaysUseObjectMode: !disableRelationsCompatibility,
+          responseWrapper: (entities) => ({
+            items: entities
+          })
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityBatchFetch",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Batch entity fetch attempt by ${actorId} failed`
+        });
+        throw err;
       }
-    ).post("/entities/by-refs", async (req, res) => {
-      const request = entitiesBatchRequest.entitiesBatchRequest(req);
-      const { items } = await entitiesCatalog.entitiesBatch({
-        entityRefs: request.entityRefs,
-        filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
-        fields: parseEntityTransformParams.parseEntityTransformParams(req.query, request.fields),
-        credentials: await httpAuth.credentials(req)
-      });
-      await write.writeEntitiesResponse({
-        res,
-        items,
-        alwaysUseObjectMode: !disableRelationsCompatibility,
-        responseWrapper: (entities) => ({
-          items: entities
-        })
-      });
     }).get("/entity-facets", async (req, res) => {
-      const response = await entitiesCatalog.facets({
-        filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
-        facets: parseEntityFacetParams.parseEntityFacetParams(req.query),
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(response);
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFacetFetch",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          message: `Entity facet fetch attempt initiated by ${actorId}`
+        });
+        const response = await entitiesCatalog.facets({
+          filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
+          facets: parseEntityFacetParams.parseEntityFacetParams(req.query),
+          credentials: await httpAuth.credentials(req)
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFacetFetch",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          response: { status: 200 },
+          message: `Entity facet fetch attempt by ${actorId} succeeded`
+        });
+        res.status(200).json(response);
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFacetFetch",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Entity facet fetch attempt by ${actorId} failed`
+        });
+        throw err;
+      }
     });
   }
   if (locationService) {
     router$1.post("/locations", async (req, res) => {
+      const credentials = await httpAuth.credentials(req);
+      const actorId = await auditLogger.getActorId(req);
       const location = await util.validateRequestBody(req, util.locationInput);
       const dryRun = yn__default.default(req.query.dryRun, { default: false });
-      if (!dryRun) {
-        util.disallowReadonlyMode(readonlyEnabled);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationCreation",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          metadata: {
+            location,
+            isDryRun: dryRun
+          },
+          request: req,
+          message: `Creation attempt of location entity for ${location.target} initiated by ${actorId}`
+        });
+        if (!dryRun) {
+          util.disallowReadonlyMode(readonlyEnabled);
+        }
+        const output = await locationService.createLocation(
+          location,
+          dryRun,
+          {
+            credentials
+          }
+        );
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationCreation",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          metadata: {
+            location: output.location,
+            isDryRun: dryRun
+          },
+          request: req,
+          response: {
+            status: 201
+          },
+          message: `Creation of location entity for ${location.target} initiated by ${actorId} succeeded`
+        });
+        res.status(201).json(output);
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationCreation",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          metadata: {
+            location,
+            isDryRun: dryRun
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Creation of location entity for ${location.target} initiated by ${actorId} failed`
+        });
+        throw err;
       }
-      const output = await locationService.createLocation(location, dryRun, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(201).json(output);
     }).get("/locations", async (req, res) => {
-      const locations = await locationService.listLocations({
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(locations.map((l) => ({ data: l })));
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetch",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          request: req,
+          message: `Fetch attempt of locations initiated by ${actorId}`
+        });
+        const locations = await locationService.listLocations({
+          credentials: await httpAuth.credentials(req)
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetch",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          request: req,
+          response: {
+            status: 200
+          },
+          message: `Fetch attempt of locations by ${actorId} succeeded`
+        });
+        res.status(200).json(locations.map((l) => ({ data: l })));
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetch",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Fetch attempt of locations by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get("/locations/:id", async (req, res) => {
       const { id } = req.params;
-      const output = await locationService.getLocation(id, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(output);
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchById",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          metadata: {
+            id
+          },
+          request: req,
+          message: `Fetch attempt of location with id: ${id} initiated by ${actorId}`
+        });
+        const output = await locationService.getLocation(id, {
+          credentials: await httpAuth.credentials(req)
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchById",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          metadata: {
+            id
+          },
+          response: {
+            status: 200,
+            body: output
+          },
+          request: req,
+          message: `Fetch attempt of location with id: ${id} by ${actorId} succeeded`
+        });
+        res.status(200).json(output);
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchById",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          metadata: {
+            id
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Fetch attempt of location with id: ${id} by ${actorId} failed`
+        });
+        throw err;
+      }
     }).delete("/locations/:id", async (req, res) => {
-      util.disallowReadonlyMode(readonlyEnabled);
+      const actorId = await auditLogger.getActorId(req);
       const { id } = req.params;
-      await locationService.deleteLocation(id, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(204).end();
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationDeletion",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          metadata: {
+            id
+          },
+          request: req,
+          message: `Deletion attempt of location with id: ${id} initiated by ${actorId}`
+        });
+        util.disallowReadonlyMode(readonlyEnabled);
+        const location = await locationService.getLocation(id, {
+          credentials: await httpAuth.credentials(req)
+        });
+        await locationService.deleteLocation(id, {
+          credentials: await httpAuth.credentials(req)
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationDeletion",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          metadata: {
+            location
+          },
+          response: {
+            status: 204
+          },
+          request: req,
+          message: `Deletion attempt of location with id: ${id} by ${actorId} succeeded`
+        });
+        res.status(204).end();
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationDeletion",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          metadata: {
+            id
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Deletion attempt of location with id: ${id} by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get("/locations/by-entity/:kind/:namespace/:name", async (req, res) => {
       const { kind, namespace, name } = req.params;
-      const output = await locationService.getLocationByEntity(
-        { kind, namespace, name },
-        { credentials: await httpAuth.credentials(req) }
-      );
-      res.status(200).json(output);
+      const actorId = await auditLogger.getActorId(req);
+      const locationRef = `${kind}:${namespace}/${name}`;
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchByEntityRef",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          metadata: {
+            locationRef
+          },
+          request: req,
+          message: `Fetch attempt for location ${locationRef} initiated by ${actorId}`
+        });
+        const output = await locationService.getLocationByEntity(
+          { kind, namespace, name },
+          { credentials: await httpAuth.credentials(req) }
+        );
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchByEntityRef",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          metadata: {
+            locationRef
+          },
+          response: {
+            status: 200,
+            body: output
+          },
+          request: req,
+          message: `Fetch attempt for location ${locationRef} by ${actorId} succeeded`
+        });
+        res.status(200).json(output);
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchByEntityRef",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          metadata: {
+            locationRef
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Fetch attempt for location ${locationRef} by ${actorId} failed`
+        });
+        throw err;
+      }
     });
   }
   if (locationAnalyzer) {
     router$1.post("/analyze-location", async (req, res) => {
-      const body = await util.validateRequestBody(
-        req,
-        zod.z.object({
-          location: util.locationInput,
-          catalogFilename: zod.z.string().optional()
-        })
-      );
-      const schema = zod.z.object({
-        location: util.locationInput,
-        catalogFilename: zod.z.string().optional()
-      });
-      const credentials = await httpAuth.credentials(req);
-      const parsedBody = schema.parse(body);
+      const actorId = await auditLogger.getActorId(req);
       try {
-        const output = await locationAnalyzer.analyzeLocation(
-          parsedBody,
-          credentials
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationAnalyze",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          request: req,
+          message: `Analyze location for location initiated by ${actorId}`
+        });
+        const body = await util.validateRequestBody(
+          req,
+          zod.z.object({
+            location: util.locationInput,
+            catalogFilename: zod.z.string().optional()
+          })
         );
-        res.status(200).json(output);
-      } catch (err) {
-        if (
-          // Catch errors from parse-url library.
-          err.name === "Error" && "subject_url" in err
-        ) {
-          throw new errors.InputError("The given location.target is not a URL");
+        const schema = zod.z.object({
+          location: util.locationInput,
+          catalogFilename: zod.z.string().optional()
+        });
+        const credentials = await httpAuth.credentials(req);
+        const parsedBody = schema.parse(body);
+        try {
+          const output = await locationAnalyzer.analyzeLocation(
+            parsedBody,
+            credentials
+          );
+          await auditLogger.auditLog({
+            eventName: "CatalogLocationAnalyze",
+            status: "succeeded",
+            stage: "completion",
+            actorId,
+            request: req,
+            response: {
+              status: 200,
+              body: output
+            },
+            message: `Analyze location for location by ${actorId} succeeded`
+          });
+          res.status(200).json(output);
+        } catch (err) {
+          if (
+            // Catch errors from parse-url library.
+            err.name === "Error" && "subject_url" in err
+          ) {
+            throw new errors.InputError("The given location.target is not a URL");
+          }
+          throw err;
         }
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationAnalyze",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Analyze location for location by ${actorId} failed`
+        });
         throw err;
       }
     });
   }
   if (orchestrator) {
     router$1.post("/validate-entity", async (req, res) => {
-      const bodySchema = zod.z.object({
-        entity: zod.z.unknown(),
-        location: zod.z.string()
-      });
-      let body;
-      let entity;
-      let location;
+      const actorId = await auditLogger.getActorId(req);
       try {
-        body = await util.validateRequestBody(req, bodySchema);
-        entity = util$1.validateEntityEnvelope(body.entity);
-        location = catalogModel.parseLocationRef(body.location);
-        if (location.type !== "url")
-          throw new TypeError(
-            `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`
-          );
-      } catch (err) {
-        return res.status(400).json({
-          errors: [errors.serializeError(err)]
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityValidate",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          request: req,
+          message: `Entity validation for entity initiated by ${actorId}`
         });
-      }
-      const credentials = await httpAuth.credentials(req);
-      const authorizedValidationService = new AuthorizedValidationService.AuthorizedValidationService(
-        orchestrator,
-        permissionsService
-      );
-      const processingResult = await authorizedValidationService.process(
-        {
-          entity: {
-            ...entity,
-            metadata: {
-              ...entity.metadata,
-              annotations: {
-                [catalogModel.ANNOTATION_LOCATION]: body.location,
-                [catalogModel.ANNOTATION_ORIGIN_LOCATION]: body.location,
-                ...entity.metadata.annotations
+        const bodySchema = zod.z.object({
+          entity: zod.z.unknown(),
+          location: zod.z.string()
+        });
+        let body;
+        let entity;
+        let location;
+        try {
+          body = await util.validateRequestBody(req, bodySchema);
+          entity = util$1.validateEntityEnvelope(body.entity);
+          location = catalogModel.parseLocationRef(body.location);
+          if (location.type !== "url")
+            throw new TypeError(
+              `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`
+            );
+        } catch (err) {
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityValidate",
+            status: "failed",
+            stage: "completion",
+            level: "error",
+            errors: [
+              {
+                name: err.name,
+                message: err.message,
+                stack: err.stack
+              }
+            ],
+            actorId,
+            request: req,
+            message: `Entity validation for entity initiated by ${actorId} failed`
+          });
+          return res.status(400).json({
+            errors: [errors.serializeError(err)]
+          });
+        }
+        const credentials = await httpAuth.credentials(req);
+        const authorizedValidationService = new AuthorizedValidationService.AuthorizedValidationService(
+          orchestrator,
+          permissionsService
+        );
+        const processingResult = await authorizedValidationService.process(
+          {
+            entity: {
+              ...entity,
+              metadata: {
+                ...entity.metadata,
+                annotations: {
+                  [catalogModel.ANNOTATION_LOCATION]: body.location,
+                  [catalogModel.ANNOTATION_ORIGIN_LOCATION]: body.location,
+                  ...entity.metadata.annotations
+                }
               }
             }
-          }
-        },
-        credentials
-      );
-      if (!processingResult.ok)
-        res.status(400).json({
-          errors: processingResult.errors.map((e) => errors.serializeError(e))
+          },
+          credentials
+        );
+        if (!processingResult.ok) {
+          const errors$1 = processingResult.errors.map((e) => errors.serializeError(e));
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityValidate",
+            status: "failed",
+            stage: "completion",
+            level: "error",
+            errors: errors$1,
+            response: {
+              status: 400
+            },
+            actorId,
+            request: req,
+            message: `Entity validation for entity initiated by ${actorId} failed`
+          });
+          return res.status(400).json({
+            errors: errors$1
+          });
+        }
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityValidate",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          response: {
+            status: 200
+          },
+          request: req,
+          message: `Entity validation for entity by ${actorId} succeeded`
+        });
+        return res.status(200).end();
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityValidate",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          actorId,
+          request: req,
+          message: `Entity validation for entity initiated by ${actorId} failed`
         });
-      return res.status(200).end();
+        throw err;
+      }
     });
   }
   return router$1;
diff --git a/dist/service/createRouter.cjs.js.map b/dist/service/createRouter.cjs.js.map
index b4e0bba8a49ff852fd6a91aa421a120e61acef0e..b9dfd52ddd6bd73819d8119e3358e048c5ec66e0 100644
--- a/dist/service/createRouter.cjs.js.map
+++ b/dist/service/createRouter.cjs.js.map
@@ -1 +1 @@
-{"version":3,"file":"createRouter.cjs.js","sources":["../../src/service/createRouter.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ANNOTATION_LOCATION,\n  ANNOTATION_ORIGIN_LOCATION,\n  Entity,\n  parseLocationRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { InputError, serializeError } from '@backstage/errors';\nimport express from 'express';\nimport yn from 'yn';\nimport { z } from 'zod';\nimport { Cursor, EntitiesCatalog } from '../catalog/types';\nimport { CatalogProcessingOrchestrator } from '../processing/types';\nimport { validateEntityEnvelope } from '../processing/util';\nimport {\n  basicEntityFilter,\n  entitiesBatchRequest,\n  parseEntityFilterParams,\n  parseEntityTransformParams,\n  parseQueryEntitiesParams,\n} from './request';\nimport { parseEntityFacetParams } from './request/parseEntityFacetParams';\nimport { parseEntityOrderParams } from './request/parseEntityOrderParams';\nimport { LocationService, RefreshService } from './types';\nimport {\n  disallowReadonlyMode,\n  encodeCursor,\n  locationInput,\n  validateRequestBody,\n} from './util';\nimport { createOpenApiRouter } from '../schema/openapi';\nimport { parseEntityPaginationParams } from './request/parseEntityPaginationParams';\nimport {\n  AuthService,\n  HttpAuthService,\n  LoggerService,\n  SchedulerService,\n  PermissionsService,\n} from '@backstage/backend-plugin-api';\nimport { LocationAnalyzer } from '@backstage/plugin-catalog-node';\nimport { AuthorizedValidationService } from './AuthorizedValidationService';\nimport {\n  createEntityArrayJsonStream,\n  writeEntitiesResponse,\n  writeSingleEntityResponse,\n} from './response';\n\n/**\n * Options used by {@link createRouter}.\n *\n * @public\n * @deprecated Please migrate to the new backend system as this will be removed in the future.\n */\nexport interface RouterOptions {\n  entitiesCatalog?: EntitiesCatalog;\n  locationAnalyzer?: LocationAnalyzer;\n  locationService: LocationService;\n  orchestrator?: CatalogProcessingOrchestrator;\n  refreshService?: RefreshService;\n  scheduler?: SchedulerService;\n  logger: LoggerService;\n  config: Config;\n  permissionIntegrationRouter?: express.Router;\n  auth: AuthService;\n  httpAuth: HttpAuthService;\n  permissionsService: PermissionsService;\n  disableRelationsCompatibility?: boolean;\n}\n\n/**\n * Creates a catalog router.\n */\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const router = await createOpenApiRouter({\n    validatorOptions: {\n      // We want the spec to be up to date with the expected value, but the return type needs\n      //  to be controlled by the router implementation not the request validator.\n      ignorePaths: /^\\/validate-entity\\/?$/,\n    },\n  });\n  const {\n    entitiesCatalog,\n    locationAnalyzer,\n    locationService,\n    orchestrator,\n    refreshService,\n    config,\n    logger,\n    permissionIntegrationRouter,\n    permissionsService,\n    auth,\n    httpAuth,\n    disableRelationsCompatibility = false,\n  } = options;\n\n  const readonlyEnabled =\n    config.getOptionalBoolean('catalog.readonly') || false;\n  if (readonlyEnabled) {\n    logger.info('Catalog is running in readonly mode');\n  }\n\n  if (refreshService) {\n    router.post('/refresh', async (req, res) => {\n      const { authorizationToken, ...restBody } = req.body;\n\n      const credentials = authorizationToken\n        ? await auth.authenticate(authorizationToken)\n        : await httpAuth.credentials(req);\n\n      await refreshService.refresh({\n        ...restBody,\n        credentials,\n      });\n      res.status(200).end();\n    });\n  }\n\n  if (permissionIntegrationRouter) {\n    router.use(permissionIntegrationRouter);\n  }\n\n  if (entitiesCatalog) {\n    router\n      .get('/entities', async (req, res) => {\n        const filter = parseEntityFilterParams(req.query);\n        const fields = parseEntityTransformParams(req.query);\n        const order = parseEntityOrderParams(req.query);\n        const pagination = parseEntityPaginationParams(req.query);\n        const credentials = await httpAuth.credentials(req);\n\n        // When pagination parameters are passed in, use the legacy slow path\n        // that loads all entities into memory\n\n        if (pagination || disableRelationsCompatibility !== true) {\n          const { entities, pageInfo } = await entitiesCatalog.entities({\n            filter,\n            fields,\n            order,\n            pagination,\n            credentials,\n          });\n\n          // Add a Link header to the next page\n          if (pageInfo.hasNextPage) {\n            const url = new URL(`http://ignored${req.url}`);\n            url.searchParams.delete('offset');\n            url.searchParams.set('after', pageInfo.endCursor);\n            res.setHeader('link', `<${url.pathname}${url.search}>; rel=\"next\"`);\n          }\n\n          await writeEntitiesResponse({\n            res,\n            items: entities,\n            alwaysUseObjectMode: !disableRelationsCompatibility,\n          });\n          return;\n        }\n\n        const responseStream = createEntityArrayJsonStream(res);\n        const limit = 10000;\n        let cursor: Cursor | undefined;\n\n        try {\n          let currentWrite: Promise<boolean> | undefined = undefined;\n          do {\n            const result = await entitiesCatalog.queryEntities(\n              !cursor\n                ? {\n                    credentials,\n                    fields,\n                    limit,\n                    filter,\n                    orderFields: order,\n                    skipTotalItems: true,\n                  }\n                : { credentials, fields, limit, cursor },\n            );\n\n            // Wait for previous write to complete\n            if (await currentWrite) {\n              return; // Client closed connection\n            }\n\n            if (result.items.entities.length) {\n              currentWrite = responseStream.send(result.items);\n            }\n\n            cursor = result.pageInfo?.nextCursor;\n          } while (cursor);\n\n          // Wait for last write to complete\n          await currentWrite;\n\n          responseStream.complete();\n        } finally {\n          responseStream.close();\n        }\n      })\n      .get('/entities/by-query', async (req, res) => {\n        const { items, pageInfo, totalItems } =\n          await entitiesCatalog.queryEntities({\n            limit: req.query.limit,\n            offset: req.query.offset,\n            ...parseQueryEntitiesParams(req.query),\n            credentials: await httpAuth.credentials(req),\n          });\n\n        await writeEntitiesResponse({\n          res,\n          items,\n          alwaysUseObjectMode: !disableRelationsCompatibility,\n          responseWrapper: entities => ({\n            items: entities,\n            totalItems,\n            pageInfo: {\n              ...(pageInfo.nextCursor && {\n                nextCursor: encodeCursor(pageInfo.nextCursor),\n              }),\n              ...(pageInfo.prevCursor && {\n                prevCursor: encodeCursor(pageInfo.prevCursor),\n              }),\n            },\n          }),\n        });\n      })\n      .get('/entities/by-uid/:uid', async (req, res) => {\n        const { uid } = req.params;\n        const { entities } = await entitiesCatalog.entities({\n          filter: basicEntityFilter({ 'metadata.uid': uid }),\n          credentials: await httpAuth.credentials(req),\n        });\n        writeSingleEntityResponse(res, entities, `No entity with uid ${uid}`);\n      })\n      .delete('/entities/by-uid/:uid', async (req, res) => {\n        const { uid } = req.params;\n        await entitiesCatalog.removeEntityByUid(uid, {\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(204).end();\n      })\n      .get('/entities/by-name/:kind/:namespace/:name', async (req, res) => {\n        const { kind, namespace, name } = req.params;\n        const { items } = await entitiesCatalog.entitiesBatch({\n          entityRefs: [stringifyEntityRef({ kind, namespace, name })],\n          credentials: await httpAuth.credentials(req),\n        });\n        writeSingleEntityResponse(\n          res,\n          items,\n          `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`,\n        );\n      })\n      .get(\n        '/entities/by-name/:kind/:namespace/:name/ancestry',\n        async (req, res) => {\n          const { kind, namespace, name } = req.params;\n          const entityRef = stringifyEntityRef({ kind, namespace, name });\n          const response = await entitiesCatalog.entityAncestry(entityRef, {\n            credentials: await httpAuth.credentials(req),\n          });\n          res.status(200).json(response);\n        },\n      )\n      .post('/entities/by-refs', async (req, res) => {\n        const request = entitiesBatchRequest(req);\n        const { items } = await entitiesCatalog.entitiesBatch({\n          entityRefs: request.entityRefs,\n          filter: parseEntityFilterParams(req.query),\n          fields: parseEntityTransformParams(req.query, request.fields),\n          credentials: await httpAuth.credentials(req),\n        });\n        await writeEntitiesResponse({\n          res,\n          items,\n          alwaysUseObjectMode: !disableRelationsCompatibility,\n          responseWrapper: entities => ({\n            items: entities,\n          }),\n        });\n      })\n      .get('/entity-facets', async (req, res) => {\n        const response = await entitiesCatalog.facets({\n          filter: parseEntityFilterParams(req.query),\n          facets: parseEntityFacetParams(req.query),\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(200).json(response);\n      });\n  }\n\n  if (locationService) {\n    router\n      .post('/locations', async (req, res) => {\n        const location = await validateRequestBody(req, locationInput);\n        const dryRun = yn(req.query.dryRun, { default: false });\n\n        // when in dryRun addLocation is effectively a read operation so we don't\n        // need to disallow readonly\n        if (!dryRun) {\n          disallowReadonlyMode(readonlyEnabled);\n        }\n\n        const output = await locationService.createLocation(location, dryRun, {\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(201).json(output);\n      })\n      .get('/locations', async (req, res) => {\n        const locations = await locationService.listLocations({\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(200).json(locations.map(l => ({ data: l })));\n      })\n\n      .get('/locations/:id', async (req, res) => {\n        const { id } = req.params;\n        const output = await locationService.getLocation(id, {\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(200).json(output);\n      })\n      .delete('/locations/:id', async (req, res) => {\n        disallowReadonlyMode(readonlyEnabled);\n\n        const { id } = req.params;\n        await locationService.deleteLocation(id, {\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(204).end();\n      })\n      .get('/locations/by-entity/:kind/:namespace/:name', async (req, res) => {\n        const { kind, namespace, name } = req.params;\n        const output = await locationService.getLocationByEntity(\n          { kind, namespace, name },\n          { credentials: await httpAuth.credentials(req) },\n        );\n        res.status(200).json(output);\n      });\n  }\n\n  if (locationAnalyzer) {\n    router.post('/analyze-location', async (req, res) => {\n      const body = await validateRequestBody(\n        req,\n        z.object({\n          location: locationInput,\n          catalogFilename: z.string().optional(),\n        }),\n      );\n      const schema = z.object({\n        location: locationInput,\n        catalogFilename: z.string().optional(),\n      });\n      const credentials = await httpAuth.credentials(req);\n      const parsedBody = schema.parse(body);\n      try {\n        const output = await locationAnalyzer.analyzeLocation(\n          parsedBody,\n          credentials,\n        );\n        res.status(200).json(output);\n      } catch (err) {\n        if (\n          // Catch errors from parse-url library.\n          err.name === 'Error' &&\n          'subject_url' in err\n        ) {\n          throw new InputError('The given location.target is not a URL');\n        }\n        throw err;\n      }\n    });\n  }\n\n  if (orchestrator) {\n    router.post('/validate-entity', async (req, res) => {\n      const bodySchema = z.object({\n        entity: z.unknown(),\n        location: z.string(),\n      });\n\n      let body: z.infer<typeof bodySchema>;\n      let entity: Entity;\n      let location: { type: string; target: string };\n      try {\n        body = await validateRequestBody(req, bodySchema);\n        entity = validateEntityEnvelope(body.entity);\n        location = parseLocationRef(body.location);\n        if (location.type !== 'url')\n          throw new TypeError(\n            `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`,\n          );\n      } catch (err) {\n        return res.status(400).json({\n          errors: [serializeError(err)],\n        });\n      }\n\n      const credentials = await httpAuth.credentials(req);\n      const authorizedValidationService = new AuthorizedValidationService(\n        orchestrator,\n        permissionsService,\n      );\n      const processingResult = await authorizedValidationService.process(\n        {\n          entity: {\n            ...entity,\n            metadata: {\n              ...entity.metadata,\n              annotations: {\n                [ANNOTATION_LOCATION]: body.location,\n                [ANNOTATION_ORIGIN_LOCATION]: body.location,\n                ...entity.metadata.annotations,\n              },\n            },\n          },\n        },\n        credentials,\n      );\n\n      if (!processingResult.ok)\n        res.status(400).json({\n          errors: processingResult.errors.map(e => serializeError(e)),\n        });\n      return res.status(200).end();\n    });\n  }\n\n  return router;\n}\n"],"names":["router","createOpenApiRouter","parseEntityFilterParams","parseEntityTransformParams","parseEntityOrderParams","parseEntityPaginationParams","writeEntitiesResponse","createEntityArrayJsonStream","parseQueryEntitiesParams","encodeCursor","basicEntityFilter","writeSingleEntityResponse","stringifyEntityRef","entitiesBatchRequest","parseEntityFacetParams","validateRequestBody","locationInput","yn","disallowReadonlyMode","z","InputError","validateEntityEnvelope","parseLocationRef","serializeError","AuthorizedValidationService","ANNOTATION_LOCATION","ANNOTATION_ORIGIN_LOCATION"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"createRouter.cjs.js","sources":["../../src/service/createRouter.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ANNOTATION_LOCATION,\n  ANNOTATION_ORIGIN_LOCATION,\n  Entity,\n  parseLocationRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { InputError, serializeError } from '@backstage/errors';\nimport express from 'express';\nimport yn from 'yn';\nimport { z } from 'zod';\nimport { Cursor, EntitiesCatalog } from '../catalog/types';\nimport { CatalogProcessingOrchestrator } from '../processing/types';\nimport { validateEntityEnvelope } from '../processing/util';\nimport {\n  basicEntityFilter,\n  entitiesBatchRequest,\n  parseEntityFilterParams,\n  parseEntityTransformParams,\n  parseQueryEntitiesParams,\n} from './request';\nimport { parseEntityFacetParams } from './request/parseEntityFacetParams';\nimport { parseEntityOrderParams } from './request/parseEntityOrderParams';\nimport { LocationService, RefreshService } from './types';\nimport {\n  disallowReadonlyMode,\n  encodeCursor,\n  locationInput,\n  validateRequestBody,\n} from './util';\nimport { createOpenApiRouter } from '../schema/openapi';\nimport { parseEntityPaginationParams } from './request/parseEntityPaginationParams';\nimport {\n  AuthService,\n  HttpAuthService,\n  LoggerService,\n  SchedulerService,\n  PermissionsService,\n} from '@backstage/backend-plugin-api';\nimport { LocationAnalyzer } from '@backstage/plugin-catalog-node';\nimport { AuthorizedValidationService } from './AuthorizedValidationService';\nimport {\n  createEntityArrayJsonStream,\n  writeEntitiesResponse,\n  writeSingleEntityResponse,\n} from './response';\n\nimport { DefaultAuditLogger } from '@janus-idp/backstage-plugin-audit-log-node';\n\n/**\n * Options used by {@link createRouter}.\n *\n * @public\n * @deprecated Please migrate to the new backend system as this will be removed in the future.\n */\nexport interface RouterOptions {\n  entitiesCatalog?: EntitiesCatalog;\n  locationAnalyzer?: LocationAnalyzer;\n  locationService: LocationService;\n  orchestrator?: CatalogProcessingOrchestrator;\n  refreshService?: RefreshService;\n  scheduler?: SchedulerService;\n  logger: LoggerService;\n  config: Config;\n  permissionIntegrationRouter?: express.Router;\n  auth: AuthService;\n  httpAuth: HttpAuthService;\n  permissionsService: PermissionsService;\n  disableRelationsCompatibility?: boolean;\n}\n\n/**\n * Creates a catalog router.\n */\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const router = await createOpenApiRouter({\n    validatorOptions: {\n      // We want the spec to be up to date with the expected value, but the return type needs\n      //  to be controlled by the router implementation not the request validator.\n      ignorePaths: /^\\/validate-entity\\/?$/,\n    },\n  });\n  const {\n    entitiesCatalog,\n    locationAnalyzer,\n    locationService,\n    orchestrator,\n    refreshService,\n    config,\n    logger,\n    permissionIntegrationRouter,\n    permissionsService,\n    auth,\n    httpAuth,\n    disableRelationsCompatibility = false,\n  } = options;\n\n  const auditLogger = new DefaultAuditLogger({\n    logger,\n    authService: auth,\n    httpAuthService: httpAuth,\n  });\n  const readonlyEnabled =\n    config.getOptionalBoolean('catalog.readonly') || false;\n  if (readonlyEnabled) {\n    logger.info('Catalog is running in readonly mode');\n  }\n\n  if (refreshService) {\n    // TODO: Potentially find a way to track the ancestor that gets refreshed to refresh this entity (as well as the child of that ancestor?)\n    router.post('/refresh', async (req, res) => {\n      const { authorizationToken, ...restBody } = req.body;\n      const actorId = await auditLogger.getActorId(req);\n      try {\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityRefresh',\n          actorId,\n          status: 'succeeded',\n          stage: 'initiation',\n          metadata: {\n            entityRef: restBody.entityRef,\n          },\n          request: req,\n          message: `Refresh attempt for ${restBody.entityRef} initiated by ${actorId}`,\n        });\n\n        const credentials = authorizationToken\n          ? await auth.authenticate(authorizationToken)\n          : await httpAuth.credentials(req);\n\n        await refreshService.refresh({\n          ...restBody,\n          credentials,\n        });\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityRefresh',\n          actorId,\n          status: 'succeeded',\n          stage: 'completion',\n          metadata: {\n            entityRef: restBody.entityRef,\n          },\n          response: {\n            status: 200,\n          },\n          request: req,\n          message: `Refresh attempt for ${restBody.entityRef} triggered by ${actorId}`,\n        });\n        res.status(200).end();\n      } catch (err) {\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityRefresh',\n          actorId,\n          status: 'failed',\n          stage: 'completion',\n          level: 'error',\n          errors: [\n            {\n              name: err.name,\n              message: err.message,\n              stack: err.stack,\n            },\n          ],\n          metadata: {\n            entityRef: restBody.entityRef,\n          },\n          request: req,\n          message: `Refresh attempt for ${restBody.entityRef} by ${actorId} failed`,\n        });\n        throw err;\n      }\n    });\n  }\n\n  if (permissionIntegrationRouter) {\n    router.use(permissionIntegrationRouter);\n  }\n\n  if (entitiesCatalog) {\n    router\n      .get('/entities', async (req, res) => {\n        const actorId = await auditLogger.getActorId(\n          req as unknown as express.Request,\n        );\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req as unknown as express.Request,\n            message: `Entity fetch attempt initiated by ${actorId}`,\n          });\n          const filter = parseEntityFilterParams(req.query);\n          const fields = parseEntityTransformParams(req.query);\n          const order = parseEntityOrderParams(req.query);\n          const pagination = parseEntityPaginationParams(req.query);\n          const credentials = await httpAuth.credentials(req);\n\n          // When pagination parameters are passed in, use the legacy slow path\n          // that loads all entities into memory\n\n          if (pagination || disableRelationsCompatibility !== true) {\n            const { entities, pageInfo } = await entitiesCatalog.entities({\n              filter,\n              fields,\n              order,\n              pagination,\n              credentials,\n            });\n\n            // Add a Link header to the next page\n            if (pageInfo.hasNextPage) {\n              const url = new URL(`http://ignored${req.url}`);\n              url.searchParams.delete('offset');\n              url.searchParams.set('after', pageInfo.endCursor);\n              res.setHeader(\n                'link',\n                `<${url.pathname}${url.search}>; rel=\"next\"`,\n              );\n            }\n\n            await auditLogger.auditLog({\n              eventName: 'CatalogEntityFetch',\n              actorId,\n              status: 'succeeded',\n              stage: 'completion',\n              request: req as unknown as express.Request,\n              // Let's not log out the entities since this can make the log very big due to it not being paged?\n              response: {\n                status: 200,\n              },\n              message: `Entity fetch attempt by ${actorId} succeeded`,\n            });\n\n            await writeEntitiesResponse({\n              res,\n              items: entities,\n              alwaysUseObjectMode: !disableRelationsCompatibility,\n            });\n            return;\n          }\n\n          const responseStream = createEntityArrayJsonStream(res);\n          const limit = 10000;\n          let cursor: Cursor | undefined;\n\n          try {\n            let currentWrite: Promise<boolean> | undefined = undefined;\n            do {\n              const result = await entitiesCatalog.queryEntities(\n                !cursor\n                  ? {\n                      credentials,\n                      fields,\n                      limit,\n                      filter,\n                      orderFields: order,\n                      skipTotalItems: true,\n                    }\n                  : { credentials, fields, limit, cursor },\n              );\n\n              // Wait for previous write to complete\n              if (await currentWrite) {\n                return; // Client closed connection\n              }\n\n              if (result.items.entities.length) {\n                currentWrite = responseStream.send(result.items);\n              }\n\n              cursor = result.pageInfo?.nextCursor;\n            } while (cursor);\n\n            // Wait for last write to complete\n            await currentWrite;\n\n            await auditLogger.auditLog({\n              eventName: 'CatalogEntityFetch',\n              actorId,\n              status: 'succeeded',\n              stage: 'completion',\n              request: req as unknown as express.Request,\n              // Let's not log out the entities since this can make the log very big due to it not being paged?\n              response: {\n                status: 200,\n              },\n              message: `Entity fetch attempt by ${actorId} succeeded`,\n            });\n\n            responseStream.complete();\n          } finally {\n            responseStream.close();\n          }\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetch',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req as unknown as express.Request,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Entity fetch attempt by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n\n      .get('/entities/by-query', async (req, res) => {\n        const actorId = await auditLogger.getActorId(\n          req as unknown as express.Request,\n        );\n        try {\n          await auditLogger.auditLog({\n            eventName: 'QueriedCatalogEntityFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req as unknown as express.Request,\n            message: `Queried entity fetch attempt initiated by ${actorId}`,\n          });\n          const { items, pageInfo, totalItems } =\n            await entitiesCatalog.queryEntities({\n              limit: req.query.limit,\n              offset: req.query.offset,\n              ...parseQueryEntitiesParams(req.query),\n              credentials: await httpAuth.credentials(req),\n            });\n\n          await auditLogger.auditLog({\n            eventName: 'QueriedCatalogEntityFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req as unknown as express.Request,\n            metadata: {\n              totalEntities: totalItems,\n              pageInfo: {\n                ...(pageInfo.nextCursor && {\n                  nextCursor: encodeCursor(pageInfo.nextCursor),\n                }),\n                ...(pageInfo.prevCursor && {\n                  prevCursor: encodeCursor(pageInfo.prevCursor),\n                }),\n              },\n            },\n            // Let's not log out the entities since this can make the log very big\n            response: {\n              status: 200,\n            },\n            message: `Queried entity fetch attempt by ${actorId} succeeded`,\n          });\n\n          await writeEntitiesResponse({\n            res,\n            items,\n            alwaysUseObjectMode: !disableRelationsCompatibility,\n            responseWrapper: entities => ({\n              items: entities,\n              totalItems,\n              pageInfo: {\n                ...(pageInfo.nextCursor && {\n                  nextCursor: encodeCursor(pageInfo.nextCursor),\n                }),\n                ...(pageInfo.prevCursor && {\n                  prevCursor: encodeCursor(pageInfo.prevCursor),\n                }),\n              },\n            }),\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'QueriedCatalogEntityFetch',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req as unknown as express.Request,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Queried entity fetch attempt by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/entities/by-uid/:uid', async (req, res) => {\n        const { uid } = req.params;\n        const actorId = await auditLogger.getActorId(req);\n        let entityRef: string | undefined | null;\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByUid',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            metadata: {\n              uid: uid,\n            },\n            message: `Fetch attempt for entity with uid ${uid} initiated by ${actorId}`,\n          });\n          const { entities } = await entitiesCatalog.entities({\n            filter: basicEntityFilter({ 'metadata.uid': uid }),\n            credentials: await httpAuth.credentials(req),\n          });\n          if (entities.entities.length) {\n            entityRef =\n              entities.type === 'object'\n                ? stringifyEntityRef(entities.entities[0] as Entity)\n                : entities.entities[0];\n          }\n\n          writeSingleEntityResponse(res, entities, `No entity with uid ${uid}`);\n\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByUid',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            metadata: {\n              uid: uid,\n              entityRef: entityRef,\n            },\n            response: {\n              status: 200,\n            },\n            message: `Fetch attempt for entity with uid ${uid} by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByUid',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req,\n            metadata: {\n              uid: uid,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Fetch attempt for entity with uid ${uid} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .delete('/entities/by-uid/:uid', async (req, res) => {\n        const { uid } = req.params;\n        const actorId = await auditLogger.getActorId(req);\n        let entityRef: string | undefined | null;\n        try {\n          // Get the entityRef of the UID so users can more easily identity the entity\n          const { entities } = await entitiesCatalog.entities({\n            filter: basicEntityFilter({ 'metadata.uid': uid }),\n            credentials: await httpAuth.credentials(req),\n          });\n          if (entities.entities.length) {\n            entityRef =\n              entities.type === 'object'\n                ? stringifyEntityRef(entities.entities[0] as Entity)\n                : entities.entities[0];\n          }\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityDeletion',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            metadata: {\n              uid: uid,\n              entityRef: entityRef,\n            },\n            message: `Deletion attempt for entity with uid ${uid} initiated by ${actorId}`,\n          });\n          await entitiesCatalog.removeEntityByUid(uid, {\n            credentials: await httpAuth.credentials(req),\n          });\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityDeletion',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            metadata: {\n              uid: uid,\n              entityRef: entityRef,\n            },\n            response: {\n              status: 204,\n            },\n            message: `Deletion attempt for entity with uid ${uid} by ${actorId} succeeded`,\n          });\n          res.status(204).end();\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityDeletion',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Deletion attempt for entity with uid ${uid} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/entities/by-name/:kind/:namespace/:name', async (req, res) => {\n        const { kind, namespace, name } = req.params;\n        const entityRef = stringifyEntityRef({ kind, namespace, name });\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByName',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            metadata: {\n              entityRef: entityRef,\n            },\n            message: `Fetch attempt for entity with entityRef ${entityRef} initiated by ${actorId}`,\n          });\n          const { items } = await entitiesCatalog.entitiesBatch({\n            entityRefs: [stringifyEntityRef({ kind, namespace, name })],\n            credentials: await httpAuth.credentials(req),\n          });\n\n          writeSingleEntityResponse(\n            res,\n            items,\n            `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`,\n          );\n\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByName',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            metadata: {\n              entityRef: entityRef,\n            },\n            response: {\n              status: 200,\n            },\n            message: `Fetch attempt for entity with entityRef ${entityRef} by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByName',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req,\n            metadata: {\n              entityRef: entityRef,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Fetch attempt for entity with entityRef ${entityRef} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get(\n        '/entities/by-name/:kind/:namespace/:name/ancestry',\n        async (req, res) => {\n          const { kind, namespace, name } = req.params;\n          const entityRef = stringifyEntityRef({ kind, namespace, name });\n          const actorId = await auditLogger.getActorId(req);\n          try {\n            await auditLogger.auditLog({\n              eventName: 'CatalogEntityAncestryFetch',\n              actorId,\n              status: 'succeeded',\n              stage: 'initiation',\n              request: req,\n              metadata: {\n                entityRef: entityRef,\n              },\n              message: `Fetch attempt for entity ancestor of entity ${entityRef} initiated by ${actorId}`,\n            });\n            const response = await entitiesCatalog.entityAncestry(entityRef, {\n              credentials: await httpAuth.credentials(req),\n            });\n\n            await auditLogger.auditLog({\n              eventName: 'CatalogEntityAncestryFetch',\n              actorId,\n              status: 'succeeded',\n              stage: 'completion',\n              request: req,\n              metadata: {\n                rootEntityRef: response.rootEntityRef,\n                ancestry: response.items.map(ancestryLink => {\n                  return {\n                    entityRef: stringifyEntityRef(ancestryLink.entity),\n                    parentEntityRefs: ancestryLink.parentEntityRefs,\n                  };\n                }),\n              },\n              response: {\n                status: 200,\n              },\n              message: `Fetch attempt for entity ancestor of entity ${entityRef} by ${actorId} succeeded`,\n            });\n\n            res.status(200).json(response);\n          } catch (err) {\n            await auditLogger.auditLog({\n              eventName: 'CatalogEntityAncestryFetch',\n              actorId,\n              status: 'failed',\n              stage: 'completion',\n              level: 'error',\n              request: req,\n              metadata: {\n                entityRef: entityRef,\n              },\n              errors: [\n                {\n                  name: err.name,\n                  message: err.message,\n                  stack: err.stack,\n                },\n              ],\n              message: `Fetch attempt for entity ancestor of entity ${entityRef} by ${actorId} failed`,\n            });\n            throw err;\n          }\n        },\n      )\n      .post('/entities/by-refs', async (req, res) => {\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityBatchFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            message: `Batch entity fetch attempt initiated by ${actorId}`,\n          });\n          const request = entitiesBatchRequest(req);\n          const { items } = await entitiesCatalog.entitiesBatch({\n            entityRefs: request.entityRefs,\n            filter: parseEntityFilterParams(req.query),\n            fields: parseEntityTransformParams(req.query, request.fields),\n            credentials: await httpAuth.credentials(req),\n          });\n\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityBatchFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            metadata: {\n              ...request,\n            },\n            response: {\n              status: 200,\n            },\n            message: `Batch entity fetch attempt by ${actorId} succeeded`,\n          });\n\n          await writeEntitiesResponse({\n            res,\n            items,\n            alwaysUseObjectMode: !disableRelationsCompatibility,\n            responseWrapper: entities => ({\n              items: entities,\n            }),\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityBatchFetch',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Batch entity fetch attempt by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/entity-facets', async (req, res) => {\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFacetFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            message: `Entity facet fetch attempt initiated by ${actorId}`,\n          });\n          const response = await entitiesCatalog.facets({\n            filter: parseEntityFilterParams(req.query),\n            facets: parseEntityFacetParams(req.query),\n            credentials: await httpAuth.credentials(req),\n          });\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFacetFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            response: { status: 200 },\n            message: `Entity facet fetch attempt by ${actorId} succeeded`,\n          });\n          res.status(200).json(response);\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFacetFetch',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            request: req,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Entity facet fetch attempt by ${actorId} failed`,\n          });\n          throw err;\n        }\n      });\n  }\n\n  if (locationService) {\n    router\n      .post('/locations', async (req, res) => {\n        const credentials = await httpAuth.credentials(req);\n        const actorId = await auditLogger.getActorId(req);\n        const location = await validateRequestBody(req, locationInput);\n        const dryRun = yn(req.query.dryRun, { default: false });\n\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationCreation',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            metadata: {\n              location: location,\n              isDryRun: dryRun,\n            },\n            request: req,\n            message: `Creation attempt of location entity for ${location.target} initiated by ${actorId}`,\n          });\n\n          // when in dryRun addLocation is effectively a read operation so we don't\n          // need to disallow readonly\n          if (!dryRun) {\n            disallowReadonlyMode(readonlyEnabled);\n          }\n\n          const output = await locationService.createLocation(\n            location,\n            dryRun,\n            {\n              credentials,\n            },\n          );\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationCreation',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            metadata: {\n              location: output.location,\n              isDryRun: dryRun,\n            },\n            request: req,\n            response: {\n              status: 201,\n            },\n            message: `Creation of location entity for ${location.target} initiated by ${actorId} succeeded`,\n          });\n          res.status(201).json(output);\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationCreation',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            metadata: {\n              location: location,\n              isDryRun: dryRun,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            request: req,\n            message: `Creation of location entity for ${location.target} initiated by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/locations', async (req, res) => {\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetch',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            request: req,\n            message: `Fetch attempt of locations initiated by ${actorId}`,\n          });\n          const locations = await locationService.listLocations({\n            credentials: await httpAuth.credentials(req),\n          });\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetch',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            request: req,\n            response: {\n              status: 200,\n            },\n            message: `Fetch attempt of locations by ${actorId} succeeded`,\n          });\n          res.status(200).json(locations.map(l => ({ data: l })));\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetch',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            request: req,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Fetch attempt of locations by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n\n      .get('/locations/:id', async (req, res) => {\n        const { id } = req.params;\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchById',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            request: req,\n            message: `Fetch attempt of location with id: ${id} initiated by ${actorId}`,\n          });\n          const output = await locationService.getLocation(id, {\n            credentials: await httpAuth.credentials(req),\n          });\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchById',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            response: {\n              status: 200,\n              body: output,\n            },\n            request: req,\n            message: `Fetch attempt of location with id: ${id} by ${actorId} succeeded`,\n          });\n          res.status(200).json(output);\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchById',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            request: req,\n            message: `Fetch attempt of location with id: ${id} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .delete('/locations/:id', async (req, res) => {\n        const actorId = await auditLogger.getActorId(req);\n        const { id } = req.params;\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationDeletion',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            request: req,\n            message: `Deletion attempt of location with id: ${id} initiated by ${actorId}`,\n          });\n          disallowReadonlyMode(readonlyEnabled);\n          // Grabbing the information of the location begin deleted\n          const location = await locationService.getLocation(id, {\n            credentials: await httpAuth.credentials(req),\n          });\n          await locationService.deleteLocation(id, {\n            credentials: await httpAuth.credentials(req),\n          });\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationDeletion',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            metadata: {\n              location,\n            },\n            response: {\n              status: 204,\n            },\n            request: req,\n            message: `Deletion attempt of location with id: ${id} by ${actorId} succeeded`,\n          });\n          res.status(204).end();\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationDeletion',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            request: req,\n            message: `Deletion attempt of location with id: ${id} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/locations/by-entity/:kind/:namespace/:name', async (req, res) => {\n        const { kind, namespace, name } = req.params;\n        const actorId = await auditLogger.getActorId(req);\n        const locationRef = `${kind}:${namespace}/${name}`;\n\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchByEntityRef',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            metadata: {\n              locationRef: locationRef,\n            },\n            request: req,\n            message: `Fetch attempt for location ${locationRef} initiated by ${actorId}`,\n          });\n\n          const output = await locationService.getLocationByEntity(\n            { kind, namespace, name },\n            { credentials: await httpAuth.credentials(req) },\n          );\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchByEntityRef',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            metadata: {\n              locationRef: locationRef,\n            },\n            response: {\n              status: 200,\n              body: output,\n            },\n            request: req,\n            message: `Fetch attempt for location ${locationRef} by ${actorId} succeeded`,\n          });\n          res.status(200).json(output);\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchByEntityRef',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            metadata: {\n              locationRef: locationRef,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            request: req,\n            message: `Fetch attempt for location ${locationRef} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      });\n  }\n\n  if (locationAnalyzer) {\n    router.post('/analyze-location', async (req, res) => {\n      const actorId = await auditLogger.getActorId(req);\n\n      try {\n        await auditLogger.auditLog({\n          eventName: 'CatalogLocationAnalyze',\n          status: 'succeeded',\n          stage: 'initiation',\n          actorId,\n          request: req,\n          message: `Analyze location for location initiated by ${actorId}`,\n        });\n        const body = await validateRequestBody(\n          req,\n          z.object({\n            location: locationInput,\n            catalogFilename: z.string().optional(),\n          }),\n        );\n        const schema = z.object({\n          location: locationInput,\n          catalogFilename: z.string().optional(),\n        });\n        const credentials = await httpAuth.credentials(req);\n        const parsedBody = schema.parse(body);\n        try {\n          const output = await locationAnalyzer.analyzeLocation(\n            parsedBody,\n            credentials,\n          );\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationAnalyze',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            request: req,\n            response: {\n              status: 200,\n              body: output,\n            },\n            message: `Analyze location for location by ${actorId} succeeded`,\n          });\n          res.status(200).json(output);\n        } catch (err) {\n          if (\n            // Catch errors from parse-url library.\n            err.name === 'Error' &&\n            'subject_url' in err\n          ) {\n            throw new InputError('The given location.target is not a URL');\n          }\n          throw err;\n        }\n      } catch (err) {\n        await auditLogger.auditLog({\n          eventName: 'CatalogLocationAnalyze',\n          status: 'failed',\n          stage: 'completion',\n          level: 'error',\n          actorId,\n          errors: [\n            {\n              name: err.name,\n              message: err.message,\n              stack: err.stack,\n            },\n          ],\n          request: req,\n          message: `Analyze location for location by ${actorId} failed`,\n        });\n        throw err;\n      }\n    });\n  }\n\n  if (orchestrator) {\n    router.post('/validate-entity', async (req, res) => {\n      const actorId = await auditLogger.getActorId(req);\n\n      try {\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityValidate',\n          status: 'succeeded',\n          stage: 'initiation',\n          actorId,\n          request: req,\n          message: `Entity validation for entity initiated by ${actorId}`,\n        });\n        const bodySchema = z.object({\n          entity: z.unknown(),\n          location: z.string(),\n        });\n\n        let body: z.infer<typeof bodySchema>;\n        let entity: Entity;\n        let location: { type: string; target: string };\n        try {\n          body = await validateRequestBody(req, bodySchema);\n          entity = validateEntityEnvelope(body.entity);\n          location = parseLocationRef(body.location);\n          if (location.type !== 'url')\n            throw new TypeError(\n              `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`,\n            );\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityValidate',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            actorId,\n            request: req,\n            message: `Entity validation for entity initiated by ${actorId} failed`,\n          });\n          return res.status(400).json({\n            errors: [serializeError(err)],\n          });\n        }\n\n        const credentials = await httpAuth.credentials(req);\n        const authorizedValidationService = new AuthorizedValidationService(\n          orchestrator,\n          permissionsService,\n        );\n\n        const processingResult = await authorizedValidationService.process(\n          {\n            entity: {\n              ...entity,\n              metadata: {\n                ...entity.metadata,\n                annotations: {\n                  [ANNOTATION_LOCATION]: body.location,\n                  [ANNOTATION_ORIGIN_LOCATION]: body.location,\n                  ...entity.metadata.annotations,\n                },\n              },\n            },\n          },\n          credentials,\n        );\n\n        if (!processingResult.ok) {\n          const errors = processingResult.errors.map(e => serializeError(e));\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityValidate',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            errors: errors,\n            response: {\n              status: 400,\n            },\n            actorId,\n            request: req,\n            message: `Entity validation for entity initiated by ${actorId} failed`,\n          });\n          return res.status(400).json({\n            errors,\n          });\n        }\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityValidate',\n          status: 'succeeded',\n          stage: 'completion',\n          actorId,\n          response: {\n            status: 200,\n          },\n          request: req,\n          message: `Entity validation for entity by ${actorId} succeeded`,\n        });\n        return res.status(200).end();\n      } catch (err) {\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityValidate',\n          status: 'failed',\n          stage: 'completion',\n          level: 'error',\n          errors: [\n            {\n              name: err.name,\n              message: err.message,\n              stack: err.stack,\n            },\n          ],\n          actorId,\n          request: req,\n          message: `Entity validation for entity initiated by ${actorId} failed`,\n        });\n        throw err;\n      }\n    });\n  }\n  return router;\n}\n"],"names":["router","createOpenApiRouter","DefaultAuditLogger","parseEntityFilterParams","parseEntityTransformParams","parseEntityOrderParams","parseEntityPaginationParams","writeEntitiesResponse","createEntityArrayJsonStream","parseQueryEntitiesParams","encodeCursor","basicEntityFilter","stringifyEntityRef","writeSingleEntityResponse","entitiesBatchRequest","parseEntityFacetParams","validateRequestBody","locationInput","yn","disallowReadonlyMode","z","InputError","validateEntityEnvelope","parseLocationRef","serializeError","AuthorizedValidationService","ANNOTATION_LOCATION","ANNOTATION_ORIGIN_LOCATION","errors"],"mappings":"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"}
\ No newline at end of file
