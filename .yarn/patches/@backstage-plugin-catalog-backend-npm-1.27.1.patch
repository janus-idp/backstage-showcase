diff --git a/dist/service/createRouter.cjs.js b/dist/service/createRouter.cjs.js
index 87c8651bca6953c2eb65181a8657f32b2250a017..b3c556992c5f4c14b5ae54c1cc81d46346829abb 100644
--- a/dist/service/createRouter.cjs.js
+++ b/dist/service/createRouter.cjs.js
@@ -17,6 +17,7 @@ var util = require('./util.cjs.js');
 var openapi_generated = require('../schema/openapi.generated.cjs.js');
 var parseEntityPaginationParams = require('./request/parseEntityPaginationParams.cjs.js');
 var AuthorizedValidationService = require('./AuthorizedValidationService.cjs.js');
+var backstagePluginAuditLogNode = require('@janus-idp/backstage-plugin-audit-log-node');
 
 function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }
 
@@ -43,6 +44,11 @@ async function createRouter(options) {
     auth,
     httpAuth
   } = options;
+  const auditLogger = new backstagePluginAuditLogNode.DefaultAuditLogger({
+    logger,
+    authService: auth,
+    httpAuthService: httpAuth
+  });
   const readonlyEnabled = config.getOptionalBoolean("catalog.readonly") || false;
   if (readonlyEnabled) {
     logger.info("Catalog is running in readonly mode");
@@ -50,12 +56,61 @@ async function createRouter(options) {
   if (refreshService) {
     router.post("/refresh", async (req, res) => {
       const { authorizationToken, ...restBody } = req.body;
-      const credentials = authorizationToken ? await auth.authenticate(authorizationToken) : await httpAuth.credentials(req);
-      await refreshService.refresh({
-        ...restBody,
-        credentials
-      });
-      res.status(200).end();
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityRefresh",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          metadata: {
+            entityRef: restBody.entityRef
+          },
+          request: req,
+          message: `Refresh attempt for ${restBody.entityRef} initiated by ${actorId}`
+        });
+        const credentials = authorizationToken ? await auth.authenticate(authorizationToken) : await httpAuth.credentials(req);
+        await refreshService.refresh({
+          ...restBody,
+          credentials
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityRefresh",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          metadata: {
+            entityRef: restBody.entityRef
+          },
+          response: {
+            status: 200
+          },
+          request: req,
+          message: `Refresh attempt for ${restBody.entityRef} triggered by ${actorId}`
+        });
+        res.status(200).end();
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityRefresh",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          metadata: {
+            entityRef: restBody.entityRef
+          },
+          request: req,
+          message: `Refresh attempt for ${restBody.entityRef} by ${actorId} failed`
+        });
+        throw err;
+      }
     });
   }
   if (permissionIntegrationRouter) {
@@ -63,217 +118,965 @@ async function createRouter(options) {
   }
   if (entitiesCatalog) {
     router.get("/entities", async (req, res) => {
-      const { entities, pageInfo } = await entitiesCatalog.entities({
-        filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
-        fields: parseEntityTransformParams.parseEntityTransformParams(req.query),
-        order: parseEntityOrderParams.parseEntityOrderParams(req.query),
-        pagination: parseEntityPaginationParams.parseEntityPaginationParams(req.query),
-        credentials: await httpAuth.credentials(req)
-      });
-      if (pageInfo.hasNextPage) {
-        const url = new URL(`http://ignored${req.url}`);
-        url.searchParams.delete("offset");
-        url.searchParams.set("after", pageInfo.endCursor);
-        res.setHeader("link", `<${url.pathname}${url.search}>; rel="next"`);
+      const actorId = await auditLogger.getActorId(
+        req
+      );
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetch",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          message: `Entity fetch attempt initiated by ${actorId}`
+        });
+        const { entities, pageInfo } = await entitiesCatalog.entities({
+          filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
+          fields: parseEntityTransformParams.parseEntityTransformParams(req.query),
+          order: parseEntityOrderParams.parseEntityOrderParams(req.query),
+          pagination: parseEntityPaginationParams.parseEntityPaginationParams(req.query),
+          credentials: await httpAuth.credentials(req)
+        });
+        if (pageInfo.hasNextPage) {
+          const url = new URL(`http://ignored${req.url}`);
+          url.searchParams.delete("offset");
+          url.searchParams.set("after", pageInfo.endCursor);
+          res.setHeader("link", `<${url.pathname}${url.search}>; rel="next"`);
+        }
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetch",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          // Let's not log out the entities since this can make the log very big due to it not being paged?
+          response: {
+            status: 200
+          },
+          message: `Entity fetch attempt by ${actorId} succeeded`
+        });
+        res.json(entities);
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetch",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Entity fetch attempt by ${actorId} failed`
+        });
+        throw err;
       }
-      res.json(entities);
     }).get("/entities/by-query", async (req, res) => {
-      const { items, pageInfo, totalItems } = await entitiesCatalog.queryEntities({
-        limit: req.query.limit,
-        offset: req.query.offset,
-        ...parseQueryEntitiesParams.parseQueryEntitiesParams(req.query),
-        credentials: await httpAuth.credentials(req)
-      });
-      res.json({
-        items,
-        totalItems,
-        pageInfo: {
-          ...pageInfo.nextCursor && {
-            nextCursor: util.encodeCursor(pageInfo.nextCursor)
-          },
-          ...pageInfo.prevCursor && {
-            prevCursor: util.encodeCursor(pageInfo.prevCursor)
+      const actorId = await auditLogger.getActorId(
+        req
+      );
+      try {
+        await auditLogger.auditLog({
+          eventName: "QueriedCatalogEntityFetch",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          message: `Queried entity fetch attempt initiated by ${actorId}`
+        });
+        const { items, pageInfo, totalItems } = await entitiesCatalog.queryEntities({
+          limit: req.query.limit,
+          ...parseQueryEntitiesParams.parseQueryEntitiesParams(req.query),
+          credentials: await httpAuth.credentials(req)
+        });
+        res.json({
+          items,
+          totalItems,
+          pageInfo: {
+            ...pageInfo.nextCursor && {
+              nextCursor: util.encodeCursor(pageInfo.nextCursor)
+            },
+            ...pageInfo.prevCursor && {
+              prevCursor: util.encodeCursor(pageInfo.prevCursor)
+            }
           }
-        }
-      });
+        });
+        await auditLogger.auditLog({
+          eventName: "QueriedCatalogEntityFetch",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            totalEntities: totalItems,
+            pageInfo: {
+              ...pageInfo.nextCursor && {
+                nextCursor: util.encodeCursor(pageInfo.nextCursor)
+              },
+              ...pageInfo.prevCursor && {
+                prevCursor: util.encodeCursor(pageInfo.prevCursor)
+              }
+            }
+          },
+          // Let's not log out the entities since this can make the log very big
+          response: {
+            status: 200
+          },
+          message: `Queried entity fetch attempt by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "QueriedCatalogEntityFetch",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Queried entity fetch attempt by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get("/entities/by-uid/:uid", async (req, res) => {
       const { uid } = req.params;
-      const { entities } = await entitiesCatalog.entities({
-        filter: basicEntityFilter.basicEntityFilter({ "metadata.uid": uid }),
-        credentials: await httpAuth.credentials(req)
-      });
-      if (!entities.length) {
-        throw new errors.NotFoundError(`No entity with uid ${uid}`);
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByUid",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          metadata: {
+            uid
+          },
+          message: `Fetch attempt for entity with uid ${uid} initiated by ${actorId}`
+        });
+        const { entities } = await entitiesCatalog.entities({
+          filter: basicEntityFilter.basicEntityFilter({ "metadata.uid": uid }),
+          credentials: await httpAuth.credentials(req)
+        });
+        if (!entities.length) {
+          throw new errors.NotFoundError(`No entity with uid ${uid}`);
+        }
+        res.status(200).json(entities[0]);
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByUid",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            uid,
+            entityRef: catalogModel.stringifyEntityRef(entities[0])
+          },
+          response: {
+            status: 200
+          },
+          message: `Fetch attempt for entity with uid ${uid} by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByUid",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          metadata: {
+            uid
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Fetch attempt for entity with uid ${uid} by ${actorId} failed`
+        });
+        throw err;
       }
-      res.status(200).json(entities[0]);
     }).delete("/entities/by-uid/:uid", async (req, res) => {
       const { uid } = req.params;
-      await entitiesCatalog.removeEntityByUid(uid, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(204).end();
+      const actorId = await auditLogger.getActorId(req);
+      let entityRef;
+      try {
+        const { entities } = await entitiesCatalog.entities({
+          filter: basicEntityFilter.basicEntityFilter({ "metadata.uid": uid }),
+          credentials: await httpAuth.credentials(req)
+        });
+        if (entities.length) {
+          entityRef = catalogModel.stringifyEntityRef(entities[0]);
+        }
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityDeletion",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          metadata: {
+            uid,
+            entityRef
+          },
+          message: `Deletion attempt for entity with uid ${uid} initiated by ${actorId}`
+        });
+        await entitiesCatalog.removeEntityByUid(uid, {
+          credentials: await httpAuth.credentials(req)
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityDeletion",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            uid,
+            entityRef
+          },
+          response: {
+            status: 204
+          },
+          message: `Deletion attempt for entity with uid ${uid} by ${actorId} succeeded`
+        });
+        res.status(204).end();
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityDeletion",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Deletion attempt for entity with uid ${uid} by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get("/entities/by-name/:kind/:namespace/:name", async (req, res) => {
       const { kind, namespace, name } = req.params;
-      const { entities } = await entitiesCatalog.entities({
-        filter: basicEntityFilter.basicEntityFilter({
-          kind,
-          "metadata.namespace": namespace,
-          "metadata.name": name
-        }),
-        credentials: await httpAuth.credentials(req)
-      });
-      if (!entities.length) {
-        throw new errors.NotFoundError(
-          `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`
-        );
+      const entityRef = catalogModel.stringifyEntityRef({ kind, namespace, name });
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByName",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          metadata: {
+            entityRef
+          },
+          message: `Fetch attempt for entity with entityRef ${entityRef} initiated by ${actorId}`
+        });
+        const { entities } = await entitiesCatalog.entities({
+          filter: basicEntityFilter.basicEntityFilter({
+            kind,
+            "metadata.namespace": namespace,
+            "metadata.name": name
+          }),
+          credentials: await httpAuth.credentials(req)
+        });
+        if (!entities.length) {
+          throw new errors.NotFoundError(
+            `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`
+          );
+        }
+        res.status(200).json(entities[0]);
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByName",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            entityRef
+          },
+          response: {
+            status: 200
+          },
+          message: `Fetch attempt for entity with entityRef ${entityRef} by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFetchByName",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          metadata: {
+            entityRef
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Fetch attempt for entity with entityRef ${entityRef} by ${actorId} failed`
+        });
+        throw err;
       }
-      res.status(200).json(entities[0]);
     }).get(
       "/entities/by-name/:kind/:namespace/:name/ancestry",
       async (req, res) => {
         const { kind, namespace, name } = req.params;
         const entityRef = catalogModel.stringifyEntityRef({ kind, namespace, name });
-        const response = await entitiesCatalog.entityAncestry(entityRef, {
+        const actorId = await auditLogger.getActorId(req);
+        try {
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityAncestryFetch",
+            actorId,
+            status: "succeeded",
+            stage: "initiation",
+            request: req,
+            metadata: {
+              entityRef
+            },
+            message: `Fetch attempt for entity ancestor of entity ${entityRef} initiated by ${actorId}`
+          });
+          const response = await entitiesCatalog.entityAncestry(entityRef, {
+            credentials: await httpAuth.credentials(req)
+          });
+          res.status(200).json(response);
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityAncestryFetch",
+            actorId,
+            status: "succeeded",
+            stage: "completion",
+            request: req,
+            metadata: {
+              rootEntityRef: response.rootEntityRef,
+              ancestry: response.items.map((ancestryLink) => {
+                return {
+                  entityRef: catalogModel.stringifyEntityRef(ancestryLink.entity),
+                  parentEntityRefs: ancestryLink.parentEntityRefs
+                };
+              })
+            },
+            response: {
+              status: 200
+            },
+            message: `Fetch attempt for entity ancestor of entity ${entityRef} by ${actorId} succeeded`
+          });
+        } catch (err) {
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityAncestryFetch",
+            actorId,
+            status: "failed",
+            stage: "completion",
+            level: "error",
+            request: req,
+            metadata: {
+              entityRef
+            },
+            errors: [
+              {
+                name: err.name,
+                message: err.message,
+                stack: err.stack
+              }
+            ],
+            message: `Fetch attempt for entity ancestor of entity ${entityRef} by ${actorId} failed`
+          });
+          throw err;
+        }
+      }
+    ).post("/entities/by-refs", async (req, res) => {
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityBatchFetch",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          message: `Batch entity fetch attempt initiated by ${actorId}`
+        });
+        const request = entitiesBatchRequest.entitiesBatchRequest(req);
+        const response = await entitiesCatalog.entitiesBatch({
+          entityRefs: request.entityRefs,
+          filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
+          fields: parseEntityTransformParams.parseEntityTransformParams(req.query, request.fields),
           credentials: await httpAuth.credentials(req)
         });
         res.status(200).json(response);
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityBatchFetch",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          metadata: {
+            ...request
+          },
+          response: {
+            status: 200
+          },
+          message: `Batch entity fetch attempt by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityBatchFetch",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Batch entity fetch attempt by ${actorId} failed`
+        });
+        throw err;
       }
-    ).post("/entities/by-refs", async (req, res) => {
-      const request = entitiesBatchRequest.entitiesBatchRequest(req);
-      const response = await entitiesCatalog.entitiesBatch({
-        entityRefs: request.entityRefs,
-        filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
-        fields: parseEntityTransformParams.parseEntityTransformParams(req.query, request.fields),
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(response);
     }).get("/entity-facets", async (req, res) => {
-      const response = await entitiesCatalog.facets({
-        filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
-        facets: parseEntityFacetParams.parseEntityFacetParams(req.query),
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(response);
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFacetFetch",
+          actorId,
+          status: "succeeded",
+          stage: "initiation",
+          request: req,
+          message: `Entity facet fetch attempt initiated by ${actorId}`
+        });
+        const response = await entitiesCatalog.facets({
+          filter: parseEntityFilterParams.parseEntityFilterParams(req.query),
+          facets: parseEntityFacetParams.parseEntityFacetParams(req.query),
+          credentials: await httpAuth.credentials(req)
+        });
+        res.status(200).json(response);
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFacetFetch",
+          actorId,
+          status: "succeeded",
+          stage: "completion",
+          request: req,
+          response: { status: 200 },
+          message: `Entity facet fetch attempt by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityFacetFetch",
+          actorId,
+          status: "failed",
+          stage: "completion",
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Entity facet fetch attempt by ${actorId} failed`
+        });
+        throw err;
+      }
     });
   }
   if (locationService) {
     router.post("/locations", async (req, res) => {
+      const credentials = await httpAuth.credentials(req);
+      const actorId = await auditLogger.getActorId(req);
       const location = await util.validateRequestBody(req, util.locationInput);
       const dryRun = yn__default.default(req.query.dryRun, { default: false });
-      if (!dryRun) {
-        util.disallowReadonlyMode(readonlyEnabled);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationCreation",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          metadata: {
+            location,
+            isDryRun: dryRun
+          },
+          request: req,
+          message: `Creation attempt of location entity for ${location.target} initiated by ${actorId}`
+        });
+        if (!dryRun) {
+          util.disallowReadonlyMode(readonlyEnabled);
+        }
+        const output = await locationService.createLocation(
+          location,
+          dryRun,
+          {
+            credentials
+          }
+        );
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationCreation",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          metadata: {
+            location: output.location,
+            isDryRun: dryRun
+          },
+          request: req,
+          response: {
+            status: 201
+          },
+          message: `Creation of location entity for ${location.target} initiated by ${actorId} succeeded`
+        });
+        res.status(201).json(output);
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationCreation",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          metadata: {
+            location,
+            isDryRun: dryRun
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Creation of location entity for ${location.target} initiated by ${actorId} failed`
+        });
+        throw err;
       }
-      const output = await locationService.createLocation(location, dryRun, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(201).json(output);
     }).get("/locations", async (req, res) => {
-      const locations = await locationService.listLocations({
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(locations.map((l) => ({ data: l })));
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetch",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          request: req,
+          message: `Fetch attempt of locations initiated by ${actorId}`
+        });
+        const locations = await locationService.listLocations({
+          credentials: await httpAuth.credentials(req)
+        });
+        res.status(200).json(locations.map((l) => ({ data: l })));
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetch",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          request: req,
+          response: {
+            status: 200
+          },
+          message: `Fetch attempt of locations by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetch",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          request: req,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          message: `Fetch attempt of locations by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get("/locations/:id", async (req, res) => {
       const { id } = req.params;
-      const output = await locationService.getLocation(id, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(200).json(output);
+      const actorId = await auditLogger.getActorId(req);
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchById",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          metadata: {
+            id
+          },
+          request: req,
+          message: `Fetch attempt of location with id: ${id} initiated by ${actorId}`
+        });
+        const output = await locationService.getLocation(id, {
+          credentials: await httpAuth.credentials(req)
+        });
+        res.status(200).json(output);
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchById",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          metadata: {
+            id
+          },
+          response: {
+            status: 200,
+            body: output
+          },
+          request: req,
+          message: `Fetch attempt of location with id: ${id} by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchById",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          metadata: {
+            id
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Fetch attempt of location with id: ${id} by ${actorId} failed`
+        });
+        throw err;
+      }
     }).delete("/locations/:id", async (req, res) => {
-      util.disallowReadonlyMode(readonlyEnabled);
+      const actorId = await auditLogger.getActorId(req);
       const { id } = req.params;
-      await locationService.deleteLocation(id, {
-        credentials: await httpAuth.credentials(req)
-      });
-      res.status(204).end();
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationDeletion",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          metadata: {
+            id
+          },
+          request: req,
+          message: `Deletion attempt of location with id: ${id} initiated by ${actorId}`
+        });
+        util.disallowReadonlyMode(readonlyEnabled);
+        const location = await locationService.getLocation(id, {
+          credentials: await httpAuth.credentials(req)
+        });
+        await locationService.deleteLocation(id, {
+          credentials: await httpAuth.credentials(req)
+        });
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationDeletion",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          metadata: {
+            location
+          },
+          response: {
+            status: 204
+          },
+          request: req,
+          message: `Deletion attempt of location with id: ${id} by ${actorId} succeeded`
+        });
+        res.status(204).end();
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationDeletion",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          metadata: {
+            id
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Deletion attempt of location with id: ${id} by ${actorId} failed`
+        });
+        throw err;
+      }
     }).get("/locations/by-entity/:kind/:namespace/:name", async (req, res) => {
       const { kind, namespace, name } = req.params;
-      const output = await locationService.getLocationByEntity(
-        { kind, namespace, name },
-        { credentials: await httpAuth.credentials(req) }
-      );
-      res.status(200).json(output);
+      const actorId = await auditLogger.getActorId(req);
+      const locationRef = `${kind}:${namespace}/${name}`;
+      try {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchByEntityRef",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          metadata: {
+            locationRef
+          },
+          request: req,
+          message: `Fetch attempt for location ${locationRef} initiated by ${actorId}`
+        });
+        const output = await locationService.getLocationByEntity(
+          { kind, namespace, name },
+          { credentials: await httpAuth.credentials(req) }
+        );
+        res.status(200).json(output);
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchByEntityRef",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          metadata: {
+            locationRef
+          },
+          response: {
+            status: 200,
+            body: output
+          },
+          request: req,
+          message: `Fetch attempt for location ${locationRef} by ${actorId} succeeded`
+        });
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationFetchByEntityRef",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          metadata: {
+            locationRef
+          },
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Fetch attempt for location ${locationRef} by ${actorId} failed`
+        });
+        throw err;
+      }
     });
   }
   if (locationAnalyzer) {
     router.post("/analyze-location", async (req, res) => {
-      const body = await util.validateRequestBody(
-        req,
-        zod.z.object({
-          location: util.locationInput,
-          catalogFilename: zod.z.string().optional()
-        })
-      );
-      const schema = zod.z.object({
-        location: util.locationInput,
-        catalogFilename: zod.z.string().optional()
-      });
-      const credentials = await httpAuth.credentials(req);
-      const parsedBody = schema.parse(body);
+      const actorId = await auditLogger.getActorId(req);
       try {
-        const output = await locationAnalyzer.analyzeLocation(
-          parsedBody,
-          credentials
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationAnalyze",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          request: req,
+          message: `Analyze location for location initiated by ${actorId}`
+        });
+        const body = await util.validateRequestBody(
+          req,
+          zod.z.object({
+            location: util.locationInput,
+            catalogFilename: zod.z.string().optional()
+          })
         );
-        res.status(200).json(output);
-      } catch (err) {
-        if (
-          // Catch errors from parse-url library.
-          err.name === "Error" && "subject_url" in err
-        ) {
-          throw new errors.InputError("The given location.target is not a URL");
+        const schema = zod.z.object({
+          location: util.locationInput,
+          catalogFilename: zod.z.string().optional()
+        });
+        const credentials = await httpAuth.credentials(req);
+        const parsedBody = schema.parse(body);
+        try {
+          const output = await locationAnalyzer.analyzeLocation(
+            parsedBody,
+            credentials
+          );
+          res.status(200).json(output);
+          await auditLogger.auditLog({
+            eventName: "CatalogLocationAnalyze",
+            status: "succeeded",
+            stage: "completion",
+            actorId,
+            request: req,
+            response: {
+              status: 200,
+              body: output
+            },
+            message: `Analyze location for location by ${actorId} succeeded`
+          });
+        } catch (err) {
+          if (
+            // Catch errors from parse-url library.
+            err.name === "Error" && "subject_url" in err
+          ) {
+            throw new errors.InputError("The given location.target is not a URL");
+          }
+          throw err;
         }
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogLocationAnalyze",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          actorId,
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          request: req,
+          message: `Analyze location for location by ${actorId} failed`
+        });
         throw err;
       }
     });
   }
   if (orchestrator) {
     router.post("/validate-entity", async (req, res) => {
-      const bodySchema = zod.z.object({
-        entity: zod.z.unknown(),
-        location: zod.z.string()
-      });
-      let body;
-      let entity;
-      let location;
+      const actorId = await auditLogger.getActorId(req);
       try {
-        body = await util.validateRequestBody(req, bodySchema);
-        entity = util$1.validateEntityEnvelope(body.entity);
-        location = catalogModel.parseLocationRef(body.location);
-        if (location.type !== "url")
-          throw new TypeError(
-            `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`
-          );
-      } catch (err) {
-        return res.status(400).json({
-          errors: [errors.serializeError(err)]
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityValidate",
+          status: "succeeded",
+          stage: "initiation",
+          actorId,
+          request: req,
+          message: `Entity validation for entity initiated by ${actorId}`
         });
-      }
-      const credentials = await httpAuth.credentials(req);
-      const authorizedValidationService = new AuthorizedValidationService.AuthorizedValidationService(
-        orchestrator,
-        permissionsService
-      );
-      const processingResult = await authorizedValidationService.process(
-        {
-          entity: {
-            ...entity,
-            metadata: {
-              ...entity.metadata,
-              annotations: {
-                [catalogModel.ANNOTATION_LOCATION]: body.location,
-                [catalogModel.ANNOTATION_ORIGIN_LOCATION]: body.location,
-                ...entity.metadata.annotations
+        const bodySchema = zod.z.object({
+          entity: zod.z.unknown(),
+          location: zod.z.string()
+        });
+        let body;
+        let entity;
+        let location;
+        try {
+          body = await util.validateRequestBody(req, bodySchema);
+          entity = util$1.validateEntityEnvelope(body.entity);
+          location = catalogModel.parseLocationRef(body.location);
+          if (location.type !== "url")
+            throw new TypeError(
+              `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`
+            );
+        } catch (err) {
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityValidate",
+            status: "failed",
+            stage: "completion",
+            level: "error",
+            errors: [
+              {
+                name: err.name,
+                message: err.message,
+                stack: err.stack
+              }
+            ],
+            actorId,
+            request: req,
+            message: `Entity validation for entity initiated by ${actorId} failed`
+          });
+          return res.status(400).json({
+            errors: [errors.serializeError(err)]
+          });
+        }
+        const credentials = await httpAuth.credentials(req);
+        const authorizedValidationService = new AuthorizedValidationService.AuthorizedValidationService(
+          orchestrator,
+          permissionsService
+        );
+        const processingResult = await authorizedValidationService.process(
+          {
+            entity: {
+              ...entity,
+              metadata: {
+                ...entity.metadata,
+                annotations: {
+                  [catalogModel.ANNOTATION_LOCATION]: body.location,
+                  [catalogModel.ANNOTATION_ORIGIN_LOCATION]: body.location,
+                  ...entity.metadata.annotations
+                }
               }
             }
-          }
-        },
-        credentials
-      );
-      if (!processingResult.ok)
-        res.status(400).json({
-          errors: processingResult.errors.map((e) => errors.serializeError(e))
+          },
+          credentials
+        );
+        if (!processingResult.ok) {
+          const errors$1 = processingResult.errors.map((e) => errors.serializeError(e));
+          await auditLogger.auditLog({
+            eventName: "CatalogEntityValidate",
+            status: "failed",
+            stage: "completion",
+            level: "error",
+            errors: errors$1,
+            response: {
+              status: 400
+            },
+            actorId,
+            request: req,
+            message: `Entity validation for entity initiated by ${actorId} failed`
+          });
+          return res.status(400).json({
+            errors: errors$1
+          });
+        }
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityValidate",
+          status: "succeeded",
+          stage: "completion",
+          actorId,
+          response: {
+            status: 200
+          },
+          request: req,
+          message: `Entity validation for entity by ${actorId} succeeded`
         });
-      return res.status(200).end();
+        return res.status(200).end();
+      } catch (err) {
+        await auditLogger.auditLog({
+          eventName: "CatalogEntityValidate",
+          status: "failed",
+          stage: "completion",
+          level: "error",
+          errors: [
+            {
+              name: err.name,
+              message: err.message,
+              stack: err.stack
+            }
+          ],
+          actorId,
+          request: req,
+          message: `Entity validation for entity initiated by ${actorId} failed`
+        });
+        throw err;
+      }
     });
   }
   router.use(backendCommon.errorHandler());
diff --git a/dist/service/createRouter.cjs.js.map b/dist/service/createRouter.cjs.js.map
index d99c14b522abceb4b397ecb4aede3b53a5f51e04..d4313425f9e28b91aabf58c2434a267879e08d6d 100644
--- a/dist/service/createRouter.cjs.js.map
+++ b/dist/service/createRouter.cjs.js.map
@@ -1 +1 @@
-{"version":3,"file":"createRouter.cjs.js","sources":["../../src/service/createRouter.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { errorHandler } from '@backstage/backend-common';\nimport {\n  ANNOTATION_LOCATION,\n  ANNOTATION_ORIGIN_LOCATION,\n  Entity,\n  parseLocationRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { InputError, NotFoundError, serializeError } from '@backstage/errors';\nimport express from 'express';\nimport yn from 'yn';\nimport { z } from 'zod';\nimport { EntitiesCatalog } from '../catalog/types';\nimport { CatalogProcessingOrchestrator } from '../processing/types';\nimport { validateEntityEnvelope } from '../processing/util';\nimport {\n  basicEntityFilter,\n  entitiesBatchRequest,\n  parseEntityFilterParams,\n  parseEntityTransformParams,\n  parseQueryEntitiesParams,\n} from './request';\nimport { parseEntityFacetParams } from './request/parseEntityFacetParams';\nimport { parseEntityOrderParams } from './request/parseEntityOrderParams';\nimport { LocationService, RefreshService } from './types';\nimport {\n  disallowReadonlyMode,\n  encodeCursor,\n  locationInput,\n  validateRequestBody,\n} from './util';\nimport { createOpenApiRouter } from '../schema/openapi.generated';\nimport { parseEntityPaginationParams } from './request/parseEntityPaginationParams';\nimport {\n  AuthService,\n  HttpAuthService,\n  LoggerService,\n  SchedulerService,\n  PermissionsService,\n} from '@backstage/backend-plugin-api';\nimport { LocationAnalyzer } from '@backstage/plugin-catalog-node';\nimport { AuthorizedValidationService } from './AuthorizedValidationService';\n\n/**\n * Options used by {@link createRouter}.\n *\n * @public\n * @deprecated Please migrate to the new backend system as this will be removed in the future.\n */\nexport interface RouterOptions {\n  entitiesCatalog?: EntitiesCatalog;\n  locationAnalyzer?: LocationAnalyzer;\n  locationService: LocationService;\n  orchestrator?: CatalogProcessingOrchestrator;\n  refreshService?: RefreshService;\n  scheduler?: SchedulerService;\n  logger: LoggerService;\n  config: Config;\n  permissionIntegrationRouter?: express.Router;\n  auth: AuthService;\n  httpAuth: HttpAuthService;\n  permissionsService: PermissionsService;\n}\n\n/**\n * Creates a catalog router.\n */\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const router = await createOpenApiRouter({\n    validatorOptions: {\n      // We want the spec to be up to date with the expected value, but the return type needs\n      //  to be controlled by the router implementation not the request validator.\n      ignorePaths: /^\\/validate-entity\\/?$/,\n    },\n  });\n  const {\n    entitiesCatalog,\n    locationAnalyzer,\n    locationService,\n    orchestrator,\n    refreshService,\n    config,\n    logger,\n    permissionIntegrationRouter,\n    permissionsService,\n    auth,\n    httpAuth,\n  } = options;\n\n  const readonlyEnabled =\n    config.getOptionalBoolean('catalog.readonly') || false;\n  if (readonlyEnabled) {\n    logger.info('Catalog is running in readonly mode');\n  }\n\n  if (refreshService) {\n    router.post('/refresh', async (req, res) => {\n      const { authorizationToken, ...restBody } = req.body;\n\n      const credentials = authorizationToken\n        ? await auth.authenticate(authorizationToken)\n        : await httpAuth.credentials(req);\n\n      await refreshService.refresh({\n        ...restBody,\n        credentials,\n      });\n      res.status(200).end();\n    });\n  }\n\n  if (permissionIntegrationRouter) {\n    router.use(permissionIntegrationRouter);\n  }\n\n  if (entitiesCatalog) {\n    router\n      .get('/entities', async (req, res) => {\n        const { entities, pageInfo } = await entitiesCatalog.entities({\n          filter: parseEntityFilterParams(req.query),\n          fields: parseEntityTransformParams(req.query),\n          order: parseEntityOrderParams(req.query),\n          pagination: parseEntityPaginationParams(req.query),\n          credentials: await httpAuth.credentials(req),\n        });\n\n        // Add a Link header to the next page\n        if (pageInfo.hasNextPage) {\n          const url = new URL(`http://ignored${req.url}`);\n          url.searchParams.delete('offset');\n          url.searchParams.set('after', pageInfo.endCursor);\n          res.setHeader('link', `<${url.pathname}${url.search}>; rel=\"next\"`);\n        }\n\n        // TODO(freben): encode the pageInfo in the response\n        res.json(entities);\n      })\n      .get('/entities/by-query', async (req, res) => {\n        const { items, pageInfo, totalItems } =\n          await entitiesCatalog.queryEntities({\n            limit: req.query.limit,\n            offset: req.query.offset,\n            ...parseQueryEntitiesParams(req.query),\n            credentials: await httpAuth.credentials(req),\n          });\n\n        res.json({\n          items,\n          totalItems,\n          pageInfo: {\n            ...(pageInfo.nextCursor && {\n              nextCursor: encodeCursor(pageInfo.nextCursor),\n            }),\n            ...(pageInfo.prevCursor && {\n              prevCursor: encodeCursor(pageInfo.prevCursor),\n            }),\n          },\n        });\n      })\n      .get('/entities/by-uid/:uid', async (req, res) => {\n        const { uid } = req.params;\n        const { entities } = await entitiesCatalog.entities({\n          filter: basicEntityFilter({ 'metadata.uid': uid }),\n          credentials: await httpAuth.credentials(req),\n        });\n        if (!entities.length) {\n          throw new NotFoundError(`No entity with uid ${uid}`);\n        }\n        res.status(200).json(entities[0]);\n      })\n      .delete('/entities/by-uid/:uid', async (req, res) => {\n        const { uid } = req.params;\n        await entitiesCatalog.removeEntityByUid(uid, {\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(204).end();\n      })\n      .get('/entities/by-name/:kind/:namespace/:name', async (req, res) => {\n        const { kind, namespace, name } = req.params;\n        const { entities } = await entitiesCatalog.entities({\n          filter: basicEntityFilter({\n            kind: kind,\n            'metadata.namespace': namespace,\n            'metadata.name': name,\n          }),\n          credentials: await httpAuth.credentials(req),\n        });\n        if (!entities.length) {\n          throw new NotFoundError(\n            `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`,\n          );\n        }\n        res.status(200).json(entities[0]);\n      })\n      .get(\n        '/entities/by-name/:kind/:namespace/:name/ancestry',\n        async (req, res) => {\n          const { kind, namespace, name } = req.params;\n          const entityRef = stringifyEntityRef({ kind, namespace, name });\n          const response = await entitiesCatalog.entityAncestry(entityRef, {\n            credentials: await httpAuth.credentials(req),\n          });\n          res.status(200).json(response);\n        },\n      )\n      .post('/entities/by-refs', async (req, res) => {\n        const request = entitiesBatchRequest(req);\n        const response = await entitiesCatalog.entitiesBatch({\n          entityRefs: request.entityRefs,\n          filter: parseEntityFilterParams(req.query),\n          fields: parseEntityTransformParams(req.query, request.fields),\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(200).json(response);\n      })\n      .get('/entity-facets', async (req, res) => {\n        const response = await entitiesCatalog.facets({\n          filter: parseEntityFilterParams(req.query),\n          facets: parseEntityFacetParams(req.query),\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(200).json(response);\n      });\n  }\n\n  if (locationService) {\n    router\n      .post('/locations', async (req, res) => {\n        const location = await validateRequestBody(req, locationInput);\n        const dryRun = yn(req.query.dryRun, { default: false });\n\n        // when in dryRun addLocation is effectively a read operation so we don't\n        // need to disallow readonly\n        if (!dryRun) {\n          disallowReadonlyMode(readonlyEnabled);\n        }\n\n        const output = await locationService.createLocation(location, dryRun, {\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(201).json(output);\n      })\n      .get('/locations', async (req, res) => {\n        const locations = await locationService.listLocations({\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(200).json(locations.map(l => ({ data: l })));\n      })\n\n      .get('/locations/:id', async (req, res) => {\n        const { id } = req.params;\n        const output = await locationService.getLocation(id, {\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(200).json(output);\n      })\n      .delete('/locations/:id', async (req, res) => {\n        disallowReadonlyMode(readonlyEnabled);\n\n        const { id } = req.params;\n        await locationService.deleteLocation(id, {\n          credentials: await httpAuth.credentials(req),\n        });\n        res.status(204).end();\n      })\n      .get('/locations/by-entity/:kind/:namespace/:name', async (req, res) => {\n        const { kind, namespace, name } = req.params;\n        const output = await locationService.getLocationByEntity(\n          { kind, namespace, name },\n          { credentials: await httpAuth.credentials(req) },\n        );\n        res.status(200).json(output);\n      });\n  }\n\n  if (locationAnalyzer) {\n    router.post('/analyze-location', async (req, res) => {\n      const body = await validateRequestBody(\n        req,\n        z.object({\n          location: locationInput,\n          catalogFilename: z.string().optional(),\n        }),\n      );\n      const schema = z.object({\n        location: locationInput,\n        catalogFilename: z.string().optional(),\n      });\n      const credentials = await httpAuth.credentials(req);\n      const parsedBody = schema.parse(body);\n      try {\n        const output = await locationAnalyzer.analyzeLocation(\n          parsedBody,\n          credentials,\n        );\n        res.status(200).json(output);\n      } catch (err) {\n        if (\n          // Catch errors from parse-url library.\n          err.name === 'Error' &&\n          'subject_url' in err\n        ) {\n          throw new InputError('The given location.target is not a URL');\n        }\n        throw err;\n      }\n    });\n  }\n\n  if (orchestrator) {\n    router.post('/validate-entity', async (req, res) => {\n      const bodySchema = z.object({\n        entity: z.unknown(),\n        location: z.string(),\n      });\n\n      let body: z.infer<typeof bodySchema>;\n      let entity: Entity;\n      let location: { type: string; target: string };\n      try {\n        body = await validateRequestBody(req, bodySchema);\n        entity = validateEntityEnvelope(body.entity);\n        location = parseLocationRef(body.location);\n        if (location.type !== 'url')\n          throw new TypeError(\n            `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`,\n          );\n      } catch (err) {\n        return res.status(400).json({\n          errors: [serializeError(err)],\n        });\n      }\n\n      const credentials = await httpAuth.credentials(req);\n      const authorizedValidationService = new AuthorizedValidationService(\n        orchestrator,\n        permissionsService,\n      );\n      const processingResult = await authorizedValidationService.process(\n        {\n          entity: {\n            ...entity,\n            metadata: {\n              ...entity.metadata,\n              annotations: {\n                [ANNOTATION_LOCATION]: body.location,\n                [ANNOTATION_ORIGIN_LOCATION]: body.location,\n                ...entity.metadata.annotations,\n              },\n            },\n          },\n        },\n        credentials,\n      );\n\n      if (!processingResult.ok)\n        res.status(400).json({\n          errors: processingResult.errors.map(e => serializeError(e)),\n        });\n      return res.status(200).end();\n    });\n  }\n\n  router.use(errorHandler());\n  return router;\n}\n"],"names":["createOpenApiRouter","parseEntityFilterParams","parseEntityTransformParams","parseEntityOrderParams","parseEntityPaginationParams","parseQueryEntitiesParams","encodeCursor","basicEntityFilter","NotFoundError","stringifyEntityRef","entitiesBatchRequest","parseEntityFacetParams","validateRequestBody","locationInput","yn","disallowReadonlyMode","z","InputError","validateEntityEnvelope","parseLocationRef","serializeError","AuthorizedValidationService","ANNOTATION_LOCATION","ANNOTATION_ORIGIN_LOCATION","errorHandler"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"createRouter.cjs.js","sources":["../../src/service/createRouter.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { errorHandler } from '@backstage/backend-common';\nimport {\n  ANNOTATION_LOCATION,\n  ANNOTATION_ORIGIN_LOCATION,\n  Entity,\n  parseLocationRef,\n  stringifyEntityRef,\n} from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { InputError, NotFoundError, serializeError } from '@backstage/errors';\nimport express from 'express';\nimport yn from 'yn';\nimport { z } from 'zod';\nimport { EntitiesCatalog } from '../catalog/types';\nimport { CatalogProcessingOrchestrator } from '../processing/types';\nimport { validateEntityEnvelope } from '../processing/util';\nimport {\n  basicEntityFilter,\n  entitiesBatchRequest,\n  parseEntityFilterParams,\n  parseEntityTransformParams,\n  parseQueryEntitiesParams,\n} from './request';\nimport { parseEntityFacetParams } from './request/parseEntityFacetParams';\nimport { parseEntityOrderParams } from './request/parseEntityOrderParams';\nimport { LocationService, RefreshService } from './types';\nimport {\n  disallowReadonlyMode,\n  encodeCursor,\n  locationInput,\n  validateRequestBody,\n} from './util';\nimport { createOpenApiRouter } from '../schema/openapi.generated';\nimport { parseEntityPaginationParams } from './request/parseEntityPaginationParams';\nimport {\n  AuthService,\n  HttpAuthService,\n  LoggerService,\n  SchedulerService,\n  PermissionsService,\n} from '@backstage/backend-plugin-api';\nimport { LocationAnalyzer } from '@backstage/plugin-catalog-node';\nimport { AuthorizedValidationService } from './AuthorizedValidationService';\n\nimport { DefaultAuditLogger } from '@janus-idp/backstage-plugin-audit-log-node';\n\n/**\n * Options used by {@link createRouter}.\n *\n * @public\n * @deprecated Please migrate to the new backend system as this will be removed in the future.\n */\nexport interface RouterOptions {\n  entitiesCatalog?: EntitiesCatalog;\n  locationAnalyzer?: LocationAnalyzer;\n  locationService: LocationService;\n  orchestrator?: CatalogProcessingOrchestrator;\n  refreshService?: RefreshService;\n  scheduler?: SchedulerService;\n  logger: LoggerService;\n  config: Config;\n  permissionIntegrationRouter?: express.Router;\n  auth: AuthService;\n  httpAuth: HttpAuthService;\n  permissionsService: PermissionsService;\n}\n\n/**\n * Creates a catalog router.\n */\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const router = await createOpenApiRouter({\n    validatorOptions: {\n      // We want the spec to be up to date with the expected value, but the return type needs\n      //  to be controlled by the router implementation not the request validator.\n      ignorePaths: /^\\/validate-entity\\/?$/,\n    },\n  });\n  const {\n    entitiesCatalog,\n    locationAnalyzer,\n    locationService,\n    orchestrator,\n    refreshService,\n    config,\n    logger,\n    permissionIntegrationRouter,\n    permissionsService,\n    auth,\n    httpAuth,\n  } = options;\n\n  const auditLogger = new DefaultAuditLogger({\n    logger,\n    authService: auth,\n    httpAuthService: httpAuth,\n  });\n  const readonlyEnabled =\n    config.getOptionalBoolean('catalog.readonly') || false;\n  if (readonlyEnabled) {\n    logger.info('Catalog is running in readonly mode');\n  }\n\n  if (refreshService) {\n    // TODO: Potentially find a way to track the ancestor that gets refreshed to refresh this entity (as well as the child of that ancestor?)\n    router.post('/refresh', async (req, res) => {\n      const { authorizationToken, ...restBody } = req.body;\n      const actorId = await auditLogger.getActorId(req);\n      try {\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityRefresh',\n          actorId,\n          status: 'succeeded',\n          stage: 'initiation',\n          metadata: {\n            entityRef: restBody.entityRef,\n          },\n          request: req,\n          message: `Refresh attempt for ${restBody.entityRef} initiated by ${actorId}`,\n        });\n\n        const credentials = authorizationToken\n          ? await auth.authenticate(authorizationToken)\n          : await httpAuth.credentials(req);\n\n        await refreshService.refresh({\n          ...restBody,\n          credentials,\n        });\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityRefresh',\n          actorId,\n          status: 'succeeded',\n          stage: 'completion',\n          metadata: {\n            entityRef: restBody.entityRef,\n          },\n          response: {\n            status: 200,\n          },\n          request: req,\n          message: `Refresh attempt for ${restBody.entityRef} triggered by ${actorId}`,\n        });\n        res.status(200).end();\n      } catch (err) {\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityRefresh',\n          actorId,\n          status: 'failed',\n          stage: 'completion',\n          level: 'error',\n          errors: [\n            {\n              name: err.name,\n              message: err.message,\n              stack: err.stack,\n            },\n          ],\n          metadata: {\n            entityRef: restBody.entityRef,\n          },\n          request: req,\n          message: `Refresh attempt for ${restBody.entityRef} by ${actorId} failed`,\n        });\n        throw err;\n      }\n    });\n  }\n\n  if (permissionIntegrationRouter) {\n    router.use(permissionIntegrationRouter);\n  }\n\n  if (entitiesCatalog) {\n    router\n      .get('/entities', async (req, res) => {\n        const actorId = await auditLogger.getActorId(\n          req as unknown as express.Request,\n        );\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req as unknown as express.Request,\n            message: `Entity fetch attempt initiated by ${actorId}`,\n          });\n          const { entities, pageInfo } = await entitiesCatalog.entities({\n            filter: parseEntityFilterParams(req.query),\n            fields: parseEntityTransformParams(req.query),\n            order: parseEntityOrderParams(req.query),\n            pagination: parseEntityPaginationParams(req.query),\n            credentials: await httpAuth.credentials(req),\n          });\n\n          // Add a Link header to the next page\n          if (pageInfo.hasNextPage) {\n            const url = new URL(`http://ignored${req.url}`);\n            url.searchParams.delete('offset');\n            url.searchParams.set('after', pageInfo.endCursor);\n            res.setHeader('link', `<${url.pathname}${url.search}>; rel=\"next\"`);\n          }\n\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req as unknown as express.Request,\n            // Let's not log out the entities since this can make the log very big due to it not being paged?\n            response: {\n              status: 200,\n            },\n            message: `Entity fetch attempt by ${actorId} succeeded`,\n          });\n\n          // TODO(freben): encode the pageInfo in the response\n          res.json(entities);\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetch',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req as unknown as express.Request,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Entity fetch attempt by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/entities/by-query', async (req, res) => {\n        const actorId = await auditLogger.getActorId(\n          req as unknown as express.Request,\n        );\n        try {\n          await auditLogger.auditLog({\n            eventName: 'QueriedCatalogEntityFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req as unknown as express.Request,\n            message: `Queried entity fetch attempt initiated by ${actorId}`,\n          });\n          const { items, pageInfo, totalItems } =\n            await entitiesCatalog.queryEntities({\n              limit: req.query.limit,\n              ...parseQueryEntitiesParams(req.query),\n              credentials: await httpAuth.credentials(req),\n            });\n\n          res.json({\n            items,\n            totalItems,\n            pageInfo: {\n              ...(pageInfo.nextCursor && {\n                nextCursor: encodeCursor(pageInfo.nextCursor),\n              }),\n              ...(pageInfo.prevCursor && {\n                prevCursor: encodeCursor(pageInfo.prevCursor),\n              }),\n            },\n          });\n          await auditLogger.auditLog({\n            eventName: 'QueriedCatalogEntityFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req as unknown as express.Request,\n            metadata: {\n              totalEntities: totalItems,\n              pageInfo: {\n                ...(pageInfo.nextCursor && {\n                  nextCursor: encodeCursor(pageInfo.nextCursor),\n                }),\n                ...(pageInfo.prevCursor && {\n                  prevCursor: encodeCursor(pageInfo.prevCursor),\n                }),\n              },\n            },\n            // Let's not log out the entities since this can make the log very big\n            response: {\n              status: 200,\n            },\n            message: `Queried entity fetch attempt by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'QueriedCatalogEntityFetch',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req as unknown as express.Request,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Queried entity fetch attempt by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/entities/by-uid/:uid', async (req, res) => {\n        const { uid } = req.params;\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByUid',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            metadata: {\n              uid: uid,\n            },\n            message: `Fetch attempt for entity with uid ${uid} initiated by ${actorId}`,\n          });\n          const { entities } = await entitiesCatalog.entities({\n            filter: basicEntityFilter({ 'metadata.uid': uid }),\n            credentials: await httpAuth.credentials(req),\n          });\n          if (!entities.length) {\n            throw new NotFoundError(`No entity with uid ${uid}`);\n          }\n          res.status(200).json(entities[0]);\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByUid',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            metadata: {\n              uid: uid,\n              entityRef: stringifyEntityRef(entities[0]),\n            },\n            response: {\n              status: 200,\n            },\n            message: `Fetch attempt for entity with uid ${uid} by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByUid',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req,\n            metadata: {\n              uid: uid,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Fetch attempt for entity with uid ${uid} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .delete('/entities/by-uid/:uid', async (req, res) => {\n        const { uid } = req.params;\n        const actorId = await auditLogger.getActorId(req);\n        let entityRef: string | undefined;\n        try {\n          // Get the entityRef of the UID so users can more easily identity the entity\n          const { entities } = await entitiesCatalog.entities({\n            filter: basicEntityFilter({ 'metadata.uid': uid }),\n            credentials: await httpAuth.credentials(req),\n          });\n          if (entities.length) {\n            entityRef = stringifyEntityRef(entities[0]);\n          }\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityDeletion',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            metadata: {\n              uid: uid,\n              entityRef: entityRef,\n            },\n            message: `Deletion attempt for entity with uid ${uid} initiated by ${actorId}`,\n          });\n          await entitiesCatalog.removeEntityByUid(uid, {\n            credentials: await httpAuth.credentials(req),\n          });\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityDeletion',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            metadata: {\n              uid: uid,\n              entityRef: entityRef,\n            },\n            response: {\n              status: 204,\n            },\n            message: `Deletion attempt for entity with uid ${uid} by ${actorId} succeeded`,\n          });\n          res.status(204).end();\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityDeletion',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Deletion attempt for entity with uid ${uid} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/entities/by-name/:kind/:namespace/:name', async (req, res) => {\n        const { kind, namespace, name } = req.params;\n        const entityRef = stringifyEntityRef({ kind, namespace, name });\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByName',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            metadata: {\n              entityRef: entityRef,\n            },\n            message: `Fetch attempt for entity with entityRef ${entityRef} initiated by ${actorId}`,\n          });\n          const { entities } = await entitiesCatalog.entities({\n            filter: basicEntityFilter({\n              kind: kind,\n              'metadata.namespace': namespace,\n              'metadata.name': name,\n            }),\n            credentials: await httpAuth.credentials(req),\n          });\n          if (!entities.length) {\n            throw new NotFoundError(\n              `No entity named '${name}' found, with kind '${kind}' in namespace '${namespace}'`,\n            );\n          }\n          res.status(200).json(entities[0]);\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByName',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            metadata: {\n              entityRef: entityRef,\n            },\n            response: {\n              status: 200,\n            },\n            message: `Fetch attempt for entity with entityRef ${entityRef} by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFetchByName',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req,\n            metadata: {\n              entityRef: entityRef,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Fetch attempt for entity with entityRef ${entityRef} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get(\n        '/entities/by-name/:kind/:namespace/:name/ancestry',\n        async (req, res) => {\n          const { kind, namespace, name } = req.params;\n          const entityRef = stringifyEntityRef({ kind, namespace, name });\n          const actorId = await auditLogger.getActorId(req);\n          try {\n            await auditLogger.auditLog({\n              eventName: 'CatalogEntityAncestryFetch',\n              actorId,\n              status: 'succeeded',\n              stage: 'initiation',\n              request: req,\n              metadata: {\n                entityRef: entityRef,\n              },\n              message: `Fetch attempt for entity ancestor of entity ${entityRef} initiated by ${actorId}`,\n            });\n            const response = await entitiesCatalog.entityAncestry(entityRef, {\n              credentials: await httpAuth.credentials(req),\n            });\n            res.status(200).json(response);\n            await auditLogger.auditLog({\n              eventName: 'CatalogEntityAncestryFetch',\n              actorId,\n              status: 'succeeded',\n              stage: 'completion',\n              request: req,\n              metadata: {\n                rootEntityRef: response.rootEntityRef,\n                ancestry: response.items.map(ancestryLink => {\n                  return {\n                    entityRef: stringifyEntityRef(ancestryLink.entity),\n                    parentEntityRefs: ancestryLink.parentEntityRefs,\n                  };\n                }),\n              },\n              response: {\n                status: 200,\n              },\n              message: `Fetch attempt for entity ancestor of entity ${entityRef} by ${actorId} succeeded`,\n            });\n          } catch (err) {\n            await auditLogger.auditLog({\n              eventName: 'CatalogEntityAncestryFetch',\n              actorId,\n              status: 'failed',\n              stage: 'completion',\n              level: 'error',\n              request: req,\n              metadata: {\n                entityRef: entityRef,\n              },\n              errors: [\n                {\n                  name: err.name,\n                  message: err.message,\n                  stack: err.stack,\n                },\n              ],\n              message: `Fetch attempt for entity ancestor of entity ${entityRef} by ${actorId} failed`,\n            });\n            throw err;\n          }\n        },\n      )\n      .post('/entities/by-refs', async (req, res) => {\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityBatchFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            message: `Batch entity fetch attempt initiated by ${actorId}`,\n          });\n          const request = entitiesBatchRequest(req);\n          const response = await entitiesCatalog.entitiesBatch({\n            entityRefs: request.entityRefs,\n            filter: parseEntityFilterParams(req.query),\n            fields: parseEntityTransformParams(req.query, request.fields),\n            credentials: await httpAuth.credentials(req),\n          });\n          res.status(200).json(response);\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityBatchFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            metadata: {\n              ...request,\n            },\n            response: {\n              status: 200,\n            },\n            message: `Batch entity fetch attempt by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityBatchFetch',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            request: req,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Batch entity fetch attempt by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/entity-facets', async (req, res) => {\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFacetFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'initiation',\n            request: req,\n            message: `Entity facet fetch attempt initiated by ${actorId}`,\n          });\n          const response = await entitiesCatalog.facets({\n            filter: parseEntityFilterParams(req.query),\n            facets: parseEntityFacetParams(req.query),\n            credentials: await httpAuth.credentials(req),\n          });\n          res.status(200).json(response);\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFacetFetch',\n            actorId,\n            status: 'succeeded',\n            stage: 'completion',\n            request: req,\n            response: { status: 200 },\n            message: `Entity facet fetch attempt by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityFacetFetch',\n            actorId,\n            status: 'failed',\n            stage: 'completion',\n            request: req,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Entity facet fetch attempt by ${actorId} failed`,\n          });\n          throw err;\n        }\n      });\n  }\n\n  if (locationService) {\n    router\n      .post('/locations', async (req, res) => {\n        const credentials = await httpAuth.credentials(req);\n        const actorId = await auditLogger.getActorId(req);\n        const location = await validateRequestBody(req, locationInput);\n        const dryRun = yn(req.query.dryRun, { default: false });\n\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationCreation',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            metadata: {\n              location: location,\n              isDryRun: dryRun,\n            },\n            request: req,\n            message: `Creation attempt of location entity for ${location.target} initiated by ${actorId}`,\n          });\n\n          // when in dryRun addLocation is effectively a read operation so we don't\n          // need to disallow readonly\n          if (!dryRun) {\n            disallowReadonlyMode(readonlyEnabled);\n          }\n\n          const output = await locationService.createLocation(\n            location,\n            dryRun,\n            {\n              credentials,\n            },\n          );\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationCreation',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            metadata: {\n              location: output.location,\n              isDryRun: dryRun,\n            },\n            request: req,\n            response: {\n              status: 201,\n            },\n            message: `Creation of location entity for ${location.target} initiated by ${actorId} succeeded`,\n          });\n          res.status(201).json(output);\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationCreation',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            metadata: {\n              location: location,\n              isDryRun: dryRun,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            request: req,\n            message: `Creation of location entity for ${location.target} initiated by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/locations', async (req, res) => {\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetch',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            request: req,\n            message: `Fetch attempt of locations initiated by ${actorId}`,\n          });\n          const locations = await locationService.listLocations({\n            credentials: await httpAuth.credentials(req),\n          });\n          res.status(200).json(locations.map(l => ({ data: l })));\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetch',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            request: req,\n            response: {\n              status: 200,\n            },\n            message: `Fetch attempt of locations by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetch',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            request: req,\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            message: `Fetch attempt of locations by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n\n      .get('/locations/:id', async (req, res) => {\n        const { id } = req.params;\n        const actorId = await auditLogger.getActorId(req);\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchById',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            request: req,\n            message: `Fetch attempt of location with id: ${id} initiated by ${actorId}`,\n          });\n          const output = await locationService.getLocation(id, {\n            credentials: await httpAuth.credentials(req),\n          });\n          res.status(200).json(output);\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchById',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            response: {\n              status: 200,\n              body: output,\n            },\n            request: req,\n            message: `Fetch attempt of location with id: ${id} by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchById',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            request: req,\n            message: `Fetch attempt of location with id: ${id} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .delete('/locations/:id', async (req, res) => {\n        const actorId = await auditLogger.getActorId(req);\n        const { id } = req.params;\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationDeletion',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            request: req,\n            message: `Deletion attempt of location with id: ${id} initiated by ${actorId}`,\n          });\n          disallowReadonlyMode(readonlyEnabled);\n          // Grabbing the information of the location begin deleted\n          const location = await locationService.getLocation(id, {\n            credentials: await httpAuth.credentials(req),\n          });\n          await locationService.deleteLocation(id, {\n            credentials: await httpAuth.credentials(req),\n          });\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationDeletion',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            metadata: {\n              location,\n            },\n            response: {\n              status: 204,\n            },\n            request: req,\n            message: `Deletion attempt of location with id: ${id} by ${actorId} succeeded`,\n          });\n          res.status(204).end();\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationDeletion',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            metadata: {\n              id: id,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            request: req,\n            message: `Deletion attempt of location with id: ${id} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      })\n      .get('/locations/by-entity/:kind/:namespace/:name', async (req, res) => {\n        const { kind, namespace, name } = req.params;\n        const actorId = await auditLogger.getActorId(req);\n        const locationRef = `${kind}:${namespace}/${name}`;\n\n        try {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchByEntityRef',\n            status: 'succeeded',\n            stage: 'initiation',\n            actorId,\n            metadata: {\n              locationRef: locationRef,\n            },\n            request: req,\n            message: `Fetch attempt for location ${locationRef} initiated by ${actorId}`,\n          });\n\n          const output = await locationService.getLocationByEntity(\n            { kind, namespace, name },\n            { credentials: await httpAuth.credentials(req) },\n          );\n          res.status(200).json(output);\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchByEntityRef',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            metadata: {\n              locationRef: locationRef,\n            },\n            response: {\n              status: 200,\n              body: output,\n            },\n            request: req,\n            message: `Fetch attempt for location ${locationRef} by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationFetchByEntityRef',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            actorId,\n            metadata: {\n              locationRef: locationRef,\n            },\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            request: req,\n            message: `Fetch attempt for location ${locationRef} by ${actorId} failed`,\n          });\n          throw err;\n        }\n      });\n  }\n\n  if (locationAnalyzer) {\n    router.post('/analyze-location', async (req, res) => {\n      const actorId = await auditLogger.getActorId(req);\n\n      try {\n        await auditLogger.auditLog({\n          eventName: 'CatalogLocationAnalyze',\n          status: 'succeeded',\n          stage: 'initiation',\n          actorId,\n          request: req,\n          message: `Analyze location for location initiated by ${actorId}`,\n        });\n        const body = await validateRequestBody(\n          req,\n          z.object({\n            location: locationInput,\n            catalogFilename: z.string().optional(),\n          }),\n        );\n        const schema = z.object({\n          location: locationInput,\n          catalogFilename: z.string().optional(),\n        });\n        const credentials = await httpAuth.credentials(req);\n        const parsedBody = schema.parse(body);\n        try {\n          const output = await locationAnalyzer.analyzeLocation(\n            parsedBody,\n            credentials,\n          );\n          res.status(200).json(output);\n          await auditLogger.auditLog({\n            eventName: 'CatalogLocationAnalyze',\n            status: 'succeeded',\n            stage: 'completion',\n            actorId,\n            request: req,\n            response: {\n              status: 200,\n              body: output,\n            },\n            message: `Analyze location for location by ${actorId} succeeded`,\n          });\n        } catch (err) {\n          if (\n            // Catch errors from parse-url library.\n            err.name === 'Error' &&\n            'subject_url' in err\n          ) {\n            throw new InputError('The given location.target is not a URL');\n          }\n          throw err;\n        }\n      } catch (err) {\n        await auditLogger.auditLog({\n          eventName: 'CatalogLocationAnalyze',\n          status: 'failed',\n          stage: 'completion',\n          level: 'error',\n          actorId,\n          errors: [\n            {\n              name: err.name,\n              message: err.message,\n              stack: err.stack,\n            },\n          ],\n          request: req,\n          message: `Analyze location for location by ${actorId} failed`,\n        });\n        throw err;\n      }\n    });\n  }\n\n  if (orchestrator) {\n    router.post('/validate-entity', async (req, res) => {\n      const actorId = await auditLogger.getActorId(req);\n\n      try {\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityValidate',\n          status: 'succeeded',\n          stage: 'initiation',\n          actorId,\n          request: req,\n          message: `Entity validation for entity initiated by ${actorId}`,\n        });\n        const bodySchema = z.object({\n          entity: z.unknown(),\n          location: z.string(),\n        });\n\n        let body: z.infer<typeof bodySchema>;\n        let entity: Entity;\n        let location: { type: string; target: string };\n        try {\n          body = await validateRequestBody(req, bodySchema);\n          entity = validateEntityEnvelope(body.entity);\n          location = parseLocationRef(body.location);\n          if (location.type !== 'url')\n            throw new TypeError(\n              `Invalid location ref ${body.location}, only 'url:<target>' is supported, e.g. url:https://host/path`,\n            );\n        } catch (err) {\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityValidate',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            errors: [\n              {\n                name: err.name,\n                message: err.message,\n                stack: err.stack,\n              },\n            ],\n            actorId,\n            request: req,\n            message: `Entity validation for entity initiated by ${actorId} failed`,\n          });\n          return res.status(400).json({\n            errors: [serializeError(err)],\n          });\n        }\n\n        const credentials = await httpAuth.credentials(req);\n        const authorizedValidationService = new AuthorizedValidationService(\n          orchestrator,\n          permissionsService,\n        );\n\n        const processingResult = await authorizedValidationService.process(\n          {\n            entity: {\n              ...entity,\n              metadata: {\n                ...entity.metadata,\n                annotations: {\n                  [ANNOTATION_LOCATION]: body.location,\n                  [ANNOTATION_ORIGIN_LOCATION]: body.location,\n                  ...entity.metadata.annotations,\n                },\n              },\n            },\n          },\n          credentials,\n        );\n\n        if (!processingResult.ok) {\n          const errors = processingResult.errors.map(e => serializeError(e));\n          await auditLogger.auditLog({\n            eventName: 'CatalogEntityValidate',\n            status: 'failed',\n            stage: 'completion',\n            level: 'error',\n            errors: errors,\n            response: {\n              status: 400,\n            },\n            actorId,\n            request: req,\n            message: `Entity validation for entity initiated by ${actorId} failed`,\n          });\n          return res.status(400).json({\n            errors,\n          });\n        }\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityValidate',\n          status: 'succeeded',\n          stage: 'completion',\n          actorId,\n          response: {\n            status: 200,\n          },\n          request: req,\n          message: `Entity validation for entity by ${actorId} succeeded`,\n        });\n        return res.status(200).end();\n      } catch (err) {\n        await auditLogger.auditLog({\n          eventName: 'CatalogEntityValidate',\n          status: 'failed',\n          stage: 'completion',\n          level: 'error',\n          errors: [\n            {\n              name: err.name,\n              message: err.message,\n              stack: err.stack,\n            },\n          ],\n          actorId,\n          request: req,\n          message: `Entity validation for entity initiated by ${actorId} failed`,\n        });\n        throw err;\n      }\n    });\n  }\n  router.use(errorHandler());\n  return router;\n}\n"],"names":["createOpenApiRouter","DefaultAuditLogger","parseEntityFilterParams","parseEntityTransformParams","parseEntityOrderParams","parseEntityPaginationParams","parseQueryEntitiesParams","encodeCursor","basicEntityFilter","NotFoundError","stringifyEntityRef","entitiesBatchRequest","parseEntityFacetParams","validateRequestBody","locationInput","yn","disallowReadonlyMode","z","InputError","validateEntityEnvelope","parseLocationRef","serializeError","AuthorizedValidationService","ANNOTATION_LOCATION","ANNOTATION_ORIGIN_LOCATION","errors","errorHandler"],"mappings":"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"}
\ No newline at end of file
