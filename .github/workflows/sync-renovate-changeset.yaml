name: Sync Renovate Changeset
on:
  pull_request_target:
    paths:
      - '.github/workflows/sync-renovate-changeset.yaml'
      - '**/yarn.lock'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.number || github.ref }}
  cancel-in-progress: true

jobs:
  generate-changeset:
    runs-on: ubuntu-latest
    if: github.actor == 'renovate[bot]' && github.repository == 'janus-idp/backstage-showcase'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}
          token: ${{ secrets.PAT }}
      - name: Configure Git
        run: |
          git config --global user.name github-actions[bot]
          git config --global user.email github-actions[bot]@users.noreply.github.com
      - name: Generate changeset
        uses: actions/github-script@v6
        with:
          script: |
            const { promises: fs } = require("fs");
            // Parses package.json files and returns the package names
            async function getPackagesNames(files) {
              const names = [];
              for (const file of files) {
                const data = JSON.parse(await fs.readFile(file, "utf8"));
                names.push(data.name);
              }
              return names;
            }

            async function createEmptyChangeset(fileName) {
              await fs.writeFile(fileName, "---\n---\n");
            }

            async function createChangeset(fileName, packageBumps, packages) {
              let message = "";
              for (const [pkg, bump] of packageBumps) {
                message = message + `Updated dependency \`${pkg}\` to \`${bump}\`.\n`;
              }

              const pkgs = packages.map((pkg) => `'${pkg}': patch`).join("\n");
              const body = `---\n${pkgs}\n---\n\n${message.trim()}\n`;
              await fs.writeFile(fileName, body);
            }

            async function getBumps(files) {
              const bumps = new Map();
              for (const file of files) {
                const { stdout: changes } = await exec.getExecOutput("git", [
                  "show",
                  file,
                ]);
                for (const change of changes.split("\n")) {
                  if (!change.startsWith("+ ")) {
                    continue;
                  }
                  const match = change.match(/"(.*?)"/g);
                  bumps.set(match[0].replace(/"/g, ""), match[1].replace(/"/g, ""));
                }
              }
              return bumps;
            }

            const branch = await exec.getExecOutput("git branch --show-current");
            if (!branch.stdout.startsWith("renovate/")) {
              console.log("Not a renovate branch, skipping");
              return;
            }

            const diffOutput = await exec.getExecOutput("git diff --name-only HEAD~1");
            const diffFiles = diffOutput.stdout.split("\n");
            if (diffFiles.find((f) => f.startsWith(".changeset"))) {
              console.log("Changeset already exists, skipping");
              return;
            }

            const { stdout: shortHash } = await exec.getExecOutput(
              "git rev-parse --short HEAD"
            );
            const fileName = `.changeset/renovate-${shortHash.trim()}.md`;

            const files = diffFiles
              .filter((file) => (file.startsWith("packages/") || file.startsWith("plugins/"))
                              && file.includes("package.json"));
            const packageNames = await getPackagesNames(files);
            const packageBumps = await getBumps(files);

            if (packageNames.length === 0 || packageBumps.size === 0) {
              console.log("No package.json changes to published packages, skipping");
              await createEmptyChangeset(fileName);
            } else {
              await createChangeset(fileName, packageBumps, packageNames);
            }

            await exec.exec("git", ["add", fileName]);
            await exec.exec("git commit -C HEAD --amend --no-edit");
            await exec.exec("git push --force");
