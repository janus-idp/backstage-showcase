diff --git a/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/alpha.cjs.js b/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/alpha.cjs.js
index 8190355..60c0887 100644
--- a/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/alpha.cjs.js
+++ b/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/alpha.cjs.js
@@ -4,7 +4,7 @@ Object.defineProperty(exports, '__esModule', { value: true });
 
 var backendPluginApi = require('@backstage/backend-plugin-api');
 var alpha = require('@backstage/plugin-catalog-node/alpha');
-var MicrosoftGraphOrgEntityProvider = require('./cjs/MicrosoftGraphOrgEntityProvider-mdJJRFUn.cjs.js');
+var MicrosoftGraphOrgEntityProvider = require('./cjs/MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js');
 require('@backstage/plugin-catalog-node');
 require('@azure/identity');
 require('node-fetch');
diff --git a/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/cjs/MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js b/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/cjs/MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js
new file mode 100644
index 0000000..70c1293
--- /dev/null
+++ b/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/cjs/MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js
@@ -0,0 +1,1136 @@
+'use strict';
+
+var catalogModel = require('@backstage/catalog-model');
+var lodash = require('lodash');
+var uuid = require('uuid');
+var identity = require('@azure/identity');
+var fetch = require('node-fetch');
+var qs = require('qs');
+var backendTasks = require('@backstage/backend-tasks');
+var limiterFactory = require('p-limit');
+
+function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }
+
+function _interopNamespaceCompat(e) {
+  if (e && typeof e === 'object' && 'default' in e) return e;
+  var n = Object.create(null);
+  if (e) {
+    Object.keys(e).forEach(function (k) {
+      if (k !== 'default') {
+        var d = Object.getOwnPropertyDescriptor(e, k);
+        Object.defineProperty(n, k, d.get ? d : {
+          enumerable: true,
+          get: function () { return e[k]; }
+        });
+      }
+    });
+  }
+  n.default = e;
+  return Object.freeze(n);
+}
+
+var uuid__namespace = /*#__PURE__*/_interopNamespaceCompat(uuid);
+var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);
+var qs__default = /*#__PURE__*/_interopDefaultCompat(qs);
+var limiterFactory__default = /*#__PURE__*/_interopDefaultCompat(limiterFactory);
+
+class MicrosoftGraphClient {
+  /**
+   * @param baseUrl - baseUrl of Graph API {@link MicrosoftGraphProviderConfig.target}
+   * @param tokenCredential - instance of `TokenCredential` that is used to acquire token for Graph API calls
+   *
+   */
+  constructor(baseUrl, tokenCredential) {
+    this.baseUrl = baseUrl;
+    this.tokenCredential = tokenCredential;
+  }
+  /**
+   * Factory method that instantiate `msal` client and return
+   * an instance of `MicrosoftGraphClient`
+   *
+   * @public
+   *
+   * @param config - Configuration for Interacting with Graph API
+   */
+  static create(config) {
+    const options = {
+      authorityHost: config.authority,
+      tenantId: config.tenantId
+    };
+    const credential = config.clientId && config.clientSecret ? new identity.ClientSecretCredential(
+      config.tenantId,
+      config.clientId,
+      config.clientSecret,
+      options
+    ) : new identity.DefaultAzureCredential(options);
+    return new MicrosoftGraphClient(config.target, credential);
+  }
+  /**
+   * Get a collection of resource from Graph API and
+   * return an `AsyncIterable` of that resource
+   *
+   * @public
+   * @param path - Resource in Microsoft Graph
+   * @param query - OData Query {@link ODataQuery}
+   * @param queryMode - Mode to use while querying. Some features are only available at "advanced".
+   */
+  async *requestCollection(path, query, queryMode) {
+    const appliedQueryMode = query?.search ? "advanced" : queryMode ?? "basic";
+    if (appliedQueryMode === "advanced" && (query?.filter || query?.select)) {
+      query.count = true;
+    }
+    const headers = appliedQueryMode === "advanced" ? {
+      // Eventual consistency is required for advanced querying capabilities
+      // like "$search" or parts of "$filter".
+      // If a new user/group is not found, it'll eventually be imported on a subsequent read
+      ConsistencyLevel: "eventual"
+    } : {};
+    let response = await this.requestApi(path, query, headers);
+    for (; ; ) {
+      if (response.status !== 200) {
+        await this.handleError(path, response);
+      }
+      const result = await response.json();
+      const elements = result.value;
+      yield* elements;
+      if (!result["@odata.nextLink"]) {
+        return;
+      }
+      response = await this.requestRaw(result["@odata.nextLink"], headers);
+    }
+  }
+  /**
+   * Abstract on top of {@link MicrosoftGraphClient.requestRaw}
+   *
+   * @public
+   * @param path - Resource in Microsoft Graph
+   * @param query - OData Query {@link ODataQuery}
+   * @param headers - optional HTTP headers
+   */
+  async requestApi(path, query, headers) {
+    const queryString = qs__default.default.stringify(
+      {
+        $search: query?.search,
+        $filter: query?.filter,
+        $select: query?.select?.join(","),
+        $expand: query?.expand,
+        $count: query?.count,
+        $top: query?.top
+      },
+      {
+        addQueryPrefix: true,
+        // Microsoft Graph doesn't like an encoded query string
+        encode: false
+      }
+    );
+    return await this.requestRaw(
+      `${this.baseUrl}/${path}${queryString}`,
+      headers
+    );
+  }
+  /**
+   * Makes a HTTP call to Graph API with token
+   *
+   * @param url - HTTP Endpoint of Graph API
+   * @param headers - optional HTTP headers
+   */
+  async requestRaw(url, headers, retryCount = 2) {
+    const urlObj = new URL(url);
+    const token = await this.tokenCredential.getToken(
+      `${urlObj.protocol}//${urlObj.hostname}/.default`
+    );
+    if (!token) {
+      throw new Error("Failed to obtain token from Azure Identity");
+    }
+    try {
+      return await fetch__default.default(url, {
+        headers: {
+          ...headers,
+          Authorization: `Bearer ${token.token}`
+        }
+      });
+    } catch (e) {
+      if (e?.code === "ETIMEDOUT" && retryCount > 0) {
+        return this.requestRaw(url, headers, retryCount - 1);
+      }
+      throw e;
+    }
+  }
+  /**
+   * Get {@link https://docs.microsoft.com/en-us/graph/api/resources/profilephoto | profilePhoto}
+   * of `User` from Graph API with size limit
+   *
+   * @param userId - The unique identifier for the `User` resource
+   * @param maxSize - Maximum pixel height of the photo
+   *
+   */
+  async getUserPhotoWithSizeLimit(userId, maxSize) {
+    return await this.getPhotoWithSizeLimit("users", userId, maxSize);
+  }
+  async getUserPhoto(userId, sizeId) {
+    return await this.getPhoto("users", userId, sizeId);
+  }
+  /**
+   * Get a collection of
+   * {@link https://docs.microsoft.com/en-us/graph/api/resources/user | User}
+   * from Graph API and return as `AsyncIterable`
+   *
+   * @public
+   * @param query - OData Query {@link ODataQuery}
+   * @param queryMode - Mode to use while querying. Some features are only available at "advanced".
+   */
+  async *getUsers(query, queryMode) {
+    yield* this.requestCollection(
+      `users`,
+      query,
+      queryMode
+    );
+  }
+  /**
+   * Get {@link https://docs.microsoft.com/en-us/graph/api/resources/profilephoto | profilePhoto}
+   * of `Group` from Graph API with size limit
+   *
+   * @param groupId - The unique identifier for the `Group` resource
+   * @param maxSize - Maximum pixel height of the photo
+   *
+   */
+  async getGroupPhotoWithSizeLimit(groupId, maxSize) {
+    return await this.getPhotoWithSizeLimit("groups", groupId, maxSize);
+  }
+  async getGroupPhoto(groupId, sizeId) {
+    return await this.getPhoto("groups", groupId, sizeId);
+  }
+  /**
+   * Get a collection of
+   * {@link https://docs.microsoft.com/en-us/graph/api/resources/group | Group}
+   * from Graph API and return as `AsyncIterable`
+   *
+   * @public
+   * @param query - OData Query {@link ODataQuery}
+   * @param queryMode - Mode to use while querying. Some features are only available at "advanced".
+   */
+  async *getGroups(query, queryMode) {
+    yield* this.requestCollection(
+      `groups`,
+      query,
+      queryMode
+    );
+  }
+  /**
+   * Get a collection of
+   * {@link https://docs.microsoft.com/en-us/graph/api/resources/user | User}
+   * belonging to a `Group` from Graph API and return as `AsyncIterable`
+   * @public
+   * @param groupId - The unique identifier for the `Group` resource
+   *
+   */
+  async *getGroupMembers(groupId, query, queryMode) {
+    yield* this.requestCollection(
+      `groups/${groupId}/members`,
+      query,
+      queryMode
+    );
+  }
+  /**
+   * Get a collection of
+   * {@link https://docs.microsoft.com/en-us/graph/api/resources/user | User}
+   * belonging to a `Group` from Graph API and return as `AsyncIterable`
+   * @public
+   * @param groupId - The unique identifier for the `Group` resource
+   * @param query - OData Query {@link ODataQuery}
+   * @param queryMode - Mode to use while querying. Some features are only available at "advanced".
+   */
+  async *getGroupUserMembers(groupId, query, queryMode) {
+    yield* this.requestCollection(
+      `groups/${groupId}/members/microsoft.graph.user/`,
+      query,
+      queryMode
+    );
+  }
+  /**
+   * Get {@link https://docs.microsoft.com/en-us/graph/api/resources/organization | Organization}
+   * from Graph API
+   * @public
+   * @param tenantId - The unique identifier for the `Organization` resource
+   *
+   */
+  async getOrganization(tenantId) {
+    const response = await this.requestApi(`organization/${tenantId}`);
+    if (response.status !== 200) {
+      await this.handleError(`organization/${tenantId}`, response);
+    }
+    return await response.json();
+  }
+  /**
+   * Get {@link https://docs.microsoft.com/en-us/graph/api/resources/profilephoto | profilePhoto}
+   * from Graph API
+   *
+   * @param entityName - type of parent resource, either `User` or `Group`
+   * @param id - The unique identifier for the {@link entityName | entityName} resource
+   * @param maxSize - Maximum pixel height of the photo
+   *
+   */
+  async getPhotoWithSizeLimit(entityName, id, maxSize) {
+    const response = await this.requestApi(`${entityName}/${id}/photos`);
+    if (response.status === 404) {
+      return void 0;
+    } else if (response.status !== 200) {
+      await this.handleError(`${entityName} photos`, response);
+    }
+    const result = await response.json();
+    const photos = result.value;
+    let selectedPhoto = void 0;
+    for (const p of photos) {
+      if (!selectedPhoto || p.height >= selectedPhoto.height && p.height <= maxSize) {
+        selectedPhoto = p;
+      }
+    }
+    if (!selectedPhoto) {
+      return void 0;
+    }
+    return await this.getPhoto(entityName, id, selectedPhoto.id);
+  }
+  async getPhoto(entityName, id, sizeId) {
+    const path = sizeId ? `${entityName}/${id}/photos/${sizeId}/$value` : `${entityName}/${id}/photo/$value`;
+    const response = await this.requestApi(path);
+    if (response.status === 404) {
+      return void 0;
+    } else if (response.status !== 200) {
+      await this.handleError("photo", response);
+    }
+    return `data:image/jpeg;base64,${Buffer.from(
+      await response.arrayBuffer()
+    ).toString("base64")}`;
+  }
+  async handleError(path, response) {
+    const result = await response.json();
+    const error = result.error;
+    throw new Error(
+      `Error while reading ${path} from Microsoft Graph: ${error.code} - ${error.message}`
+    );
+  }
+}
+
+const DEFAULT_PROVIDER_ID = "default";
+const DEFAULT_TARGET = "https://graph.microsoft.com/v1.0";
+function readMicrosoftGraphConfig(config) {
+  const providers = [];
+  const providerConfigs = config.getOptionalConfigArray("providers") ?? [];
+  for (const providerConfig of providerConfigs) {
+    const target = lodash.trimEnd(
+      providerConfig.getOptionalString("target") ?? DEFAULT_TARGET,
+      "/"
+    );
+    const authority = providerConfig.getOptionalString("authority");
+    const tenantId = providerConfig.getString("tenantId");
+    const clientId = providerConfig.getOptionalString("clientId");
+    const clientSecret = providerConfig.getOptionalString("clientSecret");
+    const userExpand = providerConfig.getOptionalString("userExpand");
+    const userFilter = providerConfig.getOptionalString("userFilter");
+    const userSelect = providerConfig.getOptionalStringArray("userSelect");
+    const userGroupMemberFilter = providerConfig.getOptionalString(
+      "userGroupMemberFilter"
+    );
+    const userGroupMemberSearch = providerConfig.getOptionalString(
+      "userGroupMemberSearch"
+    );
+    const groupExpand = providerConfig.getOptionalString("groupExpand");
+    const groupFilter = providerConfig.getOptionalString("groupFilter");
+    const groupSearch = providerConfig.getOptionalString("groupSearch");
+    if (userFilter && userGroupMemberFilter) {
+      throw new Error(
+        `userFilter and userGroupMemberFilter are mutually exclusive, only one can be specified.`
+      );
+    }
+    if (userFilter && userGroupMemberSearch) {
+      throw new Error(
+        `userGroupMemberSearch cannot be specified when userFilter is defined.`
+      );
+    }
+    const groupSelect = providerConfig.getOptionalStringArray("groupSelect");
+    const queryMode = providerConfig.getOptionalString("queryMode");
+    if (queryMode !== void 0 && queryMode !== "basic" && queryMode !== "advanced") {
+      throw new Error(`queryMode must be one of: basic, advanced`);
+    }
+    if (clientId && !clientSecret) {
+      throw new Error(
+        `clientSecret must be provided when clientId is defined.`
+      );
+    }
+    if (clientSecret && !clientId) {
+      throw new Error(
+        `clientId must be provided when clientSecret is defined.`
+      );
+    }
+    providers.push({
+      id: target,
+      target,
+      authority,
+      tenantId,
+      clientId,
+      clientSecret,
+      userExpand,
+      userFilter,
+      userSelect,
+      userGroupMemberFilter,
+      userGroupMemberSearch,
+      groupExpand,
+      groupFilter,
+      groupSearch,
+      groupSelect,
+      queryMode
+    });
+  }
+  return providers;
+}
+function readProviderConfigs(config) {
+  const providersConfig = config.getOptionalConfig(
+    "catalog.providers.microsoftGraphOrg"
+  );
+  if (!providersConfig) {
+    return [];
+  }
+  if (providersConfig.has("clientId")) {
+    return [readProviderConfig(DEFAULT_PROVIDER_ID, providersConfig)];
+  }
+  return providersConfig.keys().map((id) => {
+    const providerConfig = providersConfig.getConfig(id);
+    return readProviderConfig(id, providerConfig);
+  });
+}
+function readProviderConfig(id, config) {
+  const target = lodash.trimEnd(
+    config.getOptionalString("target") ?? DEFAULT_TARGET,
+    "/"
+  );
+  const authority = config.getOptionalString("authority");
+  const tenantId = config.getString("tenantId");
+  const clientId = config.getOptionalString("clientId");
+  const clientSecret = config.getOptionalString("clientSecret");
+  const userExpand = config.getOptionalString("user.expand");
+  const userFilter = config.getOptionalString("user.filter");
+  const userSelect = config.getOptionalStringArray("user.select");
+  const loadUserPhotos = config.getOptionalBoolean("user.loadPhotos");
+  const groupExpand = config.getOptionalString("group.expand");
+  const groupFilter = config.getOptionalString("group.filter");
+  const groupSearch = config.getOptionalString("group.search");
+  const groupSelect = config.getOptionalStringArray("group.select");
+  const queryMode = config.getOptionalString("queryMode");
+  if (queryMode !== void 0 && queryMode !== "basic" && queryMode !== "advanced") {
+    throw new Error(`queryMode must be one of: basic, advanced`);
+  }
+  const userGroupMemberFilter = config.getOptionalString(
+    "userGroupMember.filter"
+  );
+  const userGroupMemberSearch = config.getOptionalString(
+    "userGroupMember.search"
+  );
+  if (userFilter && userGroupMemberFilter) {
+    throw new Error(
+      `userFilter and userGroupMemberFilter are mutually exclusive, only one can be specified.`
+    );
+  }
+  if (userFilter && userGroupMemberSearch) {
+    throw new Error(
+      `userGroupMemberSearch cannot be specified when userFilter is defined.`
+    );
+  }
+  if (clientId && !clientSecret) {
+    throw new Error(`clientSecret must be provided when clientId is defined.`);
+  }
+  if (clientSecret && !clientId) {
+    throw new Error(`clientId must be provided when clientSecret is defined.`);
+  }
+  const schedule = config.has("schedule") ? backendTasks.readTaskScheduleDefinitionFromConfig(config.getConfig("schedule")) : void 0;
+  return {
+    id,
+    target,
+    authority,
+    clientId,
+    clientSecret,
+    tenantId,
+    userExpand,
+    userFilter,
+    userSelect,
+    loadUserPhotos,
+    groupExpand,
+    groupFilter,
+    groupSearch,
+    groupSelect,
+    queryMode,
+    userGroupMemberFilter,
+    userGroupMemberSearch,
+    schedule
+  };
+}
+
+const MICROSOFT_EMAIL_ANNOTATION = "microsoft.com/email";
+const MICROSOFT_GRAPH_TENANT_ID_ANNOTATION = "graph.microsoft.com/tenant-id";
+const MICROSOFT_GRAPH_GROUP_ID_ANNOTATION = "graph.microsoft.com/group-id";
+const MICROSOFT_GRAPH_USER_ID_ANNOTATION = "graph.microsoft.com/user-id";
+
+function normalizeEntityName(name) {
+  let cleaned = name.trim().toLocaleLowerCase().replace(/[^a-zA-Z0-9_\-\.]/g, "_");
+  while (cleaned.endsWith("_")) {
+    cleaned = cleaned.substring(0, cleaned.length - 1);
+  }
+  while (cleaned.includes("__")) {
+    cleaned = cleaned.replace("__", "_");
+  }
+  return cleaned;
+}
+
+async function defaultOrganizationTransformer(organization) {
+  if (!organization.id || !organization.displayName) {
+    return void 0;
+  }
+  const name = normalizeEntityName(organization.displayName);
+  return {
+    apiVersion: "backstage.io/v1alpha1",
+    kind: "Group",
+    metadata: {
+      name,
+      description: organization.displayName,
+      annotations: {
+        [MICROSOFT_GRAPH_TENANT_ID_ANNOTATION]: organization.id
+      }
+    },
+    spec: {
+      type: "root",
+      profile: {
+        displayName: organization.displayName
+      },
+      children: []
+    }
+  };
+}
+function extractGroupName(group) {
+  if (group.securityEnabled) {
+    return group.displayName;
+  }
+  return group.mailNickname || group.displayName;
+}
+async function defaultGroupTransformer(group, groupPhoto) {
+  if (!group.id || !group.displayName) {
+    return void 0;
+  }
+  const name = normalizeEntityName(extractGroupName(group));
+  const entity = {
+    apiVersion: "backstage.io/v1alpha1",
+    kind: "Group",
+    metadata: {
+      name,
+      annotations: {
+        [MICROSOFT_GRAPH_GROUP_ID_ANNOTATION]: group.id
+      }
+    },
+    spec: {
+      type: "team",
+      profile: {},
+      children: []
+    }
+  };
+  if (group.description) {
+    entity.metadata.description = group.description;
+  }
+  if (group.displayName) {
+    entity.spec.profile.displayName = group.displayName;
+  }
+  if (group.mail) {
+    entity.spec.profile.email = group.mail;
+  }
+  if (groupPhoto) {
+    entity.spec.profile.picture = groupPhoto;
+  }
+  return entity;
+}
+async function defaultUserTransformer(user, userPhoto) {
+  if (!user.id || !user.displayName) {
+    return void 0;
+  }
+  const name = user.mail ? normalizeEntityName(user.mail) : normalizeEntityName(user.userPrincipalName);
+  const entity = {
+    apiVersion: "backstage.io/v1alpha1",
+    kind: "User",
+    metadata: {
+      name,
+      annotations: {
+        [MICROSOFT_GRAPH_USER_ID_ANNOTATION]: user.id
+      }
+    },
+    spec: {
+      profile: {
+        displayName: user.displayName
+        // TODO: Additional fields?
+        // jobTitle: user.jobTitle || undefined,
+        // officeLocation: user.officeLocation || undefined,
+        // mobilePhone: user.mobilePhone || undefined,
+      },
+      memberOf: []
+    }
+  };
+  if (user.mail) {
+    entity.metadata.annotations[MICROSOFT_EMAIL_ANNOTATION] = user.mail;
+    entity.spec.profile.email = user.mail;
+  }
+  if (userPhoto) {
+    entity.spec.profile.picture = userPhoto;
+  }
+  return entity;
+}
+
+function buildOrgHierarchy(groups) {
+  const groupsByName = new Map(groups.map((g) => [g.metadata.name, g]));
+  for (const group of groups) {
+    const selfName = group.metadata.name;
+    const parentName = group.spec.parent;
+    if (parentName) {
+      const parent = groupsByName.get(parentName);
+      if (parent && !parent.spec.children.includes(selfName)) {
+        parent.spec.children.push(selfName);
+      }
+    }
+  }
+  for (const group of groups) {
+    const selfName = group.metadata.name;
+    for (const childName of group.spec.children) {
+      const child = groupsByName.get(childName);
+      if (child && !child.spec.parent) {
+        child.spec.parent = selfName;
+      }
+    }
+  }
+}
+function buildMemberOf(groups, users) {
+  const groupsByName = new Map(groups.map((g) => [g.metadata.name, g]));
+  users.forEach((user) => {
+    const transitiveMemberOf = /* @__PURE__ */ new Set();
+    const todo = [
+      ...user.spec.memberOf ?? [],
+      ...groups.filter((g) => g.spec.members?.includes(user.metadata.name)).map((g) => g.metadata.name)
+    ];
+    for (; ; ) {
+      const current = todo.pop();
+      if (!current) {
+        break;
+      }
+      if (!transitiveMemberOf.has(current)) {
+        transitiveMemberOf.add(current);
+        const group = groupsByName.get(current);
+        if (group?.spec.parent) {
+          todo.push(group.spec.parent);
+        }
+      }
+    }
+    user.spec.memberOf = [...transitiveMemberOf];
+  });
+}
+
+const PAGE_SIZE = 999;
+async function readMicrosoftGraphUsers(client, options) {
+  const users = client.getUsers(
+    {
+      filter: options.userFilter,
+      expand: options.userExpand,
+      select: options.userSelect,
+      top: PAGE_SIZE
+    },
+    options.queryMode
+  );
+  return {
+    users: await transformUsers(
+      client,
+      users,
+      options.logger,
+      options.loadUserPhotos,
+      options.transformer
+    )
+  };
+}
+async function readMicrosoftGraphUsersInGroups(client, options) {
+  const limiter = limiterFactory__default.default(10);
+  const userGroupMemberPromises = [];
+  const userGroupMembers = /* @__PURE__ */ new Map();
+  for await (const group of client.getGroups(
+    {
+      expand: options.groupExpand,
+      filter: options.userGroupMemberFilter,
+      search: options.userGroupMemberSearch,
+      select: ["id", "displayName"],
+      top: PAGE_SIZE
+    },
+    options.queryMode
+  )) {
+    userGroupMemberPromises.push(
+      limiter(async () => {
+        let groupMemberCount = 0;
+        for await (const user of client.getGroupUserMembers(
+          group.id,
+          {
+            expand: options.userExpand,
+            filter: options.userFilter,
+            select: options.userSelect,
+            top: PAGE_SIZE
+          },
+          options.queryMode
+        )) {
+          userGroupMembers.set(user.id, user);
+          groupMemberCount++;
+        }
+        options.logger.debug("Read users from group", {
+          groupId: group.id,
+          groupName: group.displayName,
+          memberCount: groupMemberCount
+        });
+      })
+    );
+  }
+  await Promise.all(userGroupMemberPromises);
+  options.logger.info("Read users from group membership", {
+    groupCount: userGroupMemberPromises.length,
+    userCount: userGroupMembers.size
+  });
+  return {
+    users: await transformUsers(
+      client,
+      userGroupMembers.values(),
+      options.logger,
+      options.loadUserPhotos,
+      options.transformer
+    )
+  };
+}
+async function readMicrosoftGraphOrganization(client, tenantId, options) {
+  const organization = await client.getOrganization(tenantId);
+  const transformer = options?.transformer ?? defaultOrganizationTransformer;
+  const rootGroup = await transformer(organization);
+  return { rootGroup };
+}
+async function readMicrosoftGraphGroups(client, tenantId, options) {
+  const groups = [];
+  const groupMember = /* @__PURE__ */ new Map();
+  const groupMemberOf = /* @__PURE__ */ new Map();
+  const limiter = limiterFactory__default.default(10);
+  const { rootGroup } = await readMicrosoftGraphOrganization(client, tenantId, {
+    transformer: options?.organizationTransformer
+  });
+  if (rootGroup) {
+    groupMember.set(rootGroup.metadata.name, /* @__PURE__ */ new Set());
+    groups.push(rootGroup);
+  }
+  const transformer = options?.groupTransformer ?? defaultGroupTransformer;
+  const promises = [];
+  for await (const group of client.getGroups(
+    {
+      expand: options?.groupExpand,
+      filter: options?.groupFilter,
+      search: options?.groupSearch,
+      select: options?.groupSelect,
+      top: PAGE_SIZE
+    },
+    options?.queryMode
+  )) {
+    promises.push(
+      limiter(async () => {
+        const entity = await transformer(
+          group
+          /* , groupPhoto*/
+        );
+        if (!entity) {
+          return;
+        }
+        for await (const member of client.getGroupMembers(group.id, {
+          top: PAGE_SIZE
+        })) {
+          if (!member.id) {
+            continue;
+          }
+          if (member["@odata.type"] === "#microsoft.graph.user") {
+            ensureItem(groupMemberOf, member.id, group.id);
+          }
+          if (member["@odata.type"] === "#microsoft.graph.group") {
+            ensureItem(groupMember, group.id, member.id);
+          }
+        }
+        groups.push(entity);
+      })
+    );
+  }
+  await Promise.all(promises);
+  return {
+    groups,
+    rootGroup,
+    groupMember,
+    groupMemberOf
+  };
+}
+function resolveRelations(rootGroup, groups, users, groupMember, groupMemberOf) {
+  const groupMap = /* @__PURE__ */ new Map();
+  for (const group of groups) {
+    if (group.metadata.annotations[MICROSOFT_GRAPH_GROUP_ID_ANNOTATION]) {
+      groupMap.set(
+        group.metadata.annotations[MICROSOFT_GRAPH_GROUP_ID_ANNOTATION],
+        group
+      );
+    }
+    if (group.metadata.annotations[MICROSOFT_GRAPH_TENANT_ID_ANNOTATION]) {
+      groupMap.set(
+        group.metadata.annotations[MICROSOFT_GRAPH_TENANT_ID_ANNOTATION],
+        group
+      );
+    }
+  }
+  const parentGroups = /* @__PURE__ */ new Map();
+  groupMember.forEach(
+    (members, groupId) => members.forEach((m) => ensureItem(parentGroups, m, groupId))
+  );
+  if (rootGroup) {
+    const tenantId = rootGroup.metadata.annotations[MICROSOFT_GRAPH_TENANT_ID_ANNOTATION];
+    groups.forEach((group) => {
+      const groupId = group.metadata.annotations[MICROSOFT_GRAPH_GROUP_ID_ANNOTATION];
+      if (!groupId) {
+        return;
+      }
+      if (retrieveItems(parentGroups, groupId).size === 0) {
+        ensureItem(parentGroups, groupId, tenantId);
+        ensureItem(groupMember, tenantId, groupId);
+      }
+    });
+  }
+  groups.forEach((group) => {
+    const id = group.metadata.annotations[MICROSOFT_GRAPH_GROUP_ID_ANNOTATION] ?? group.metadata.annotations[MICROSOFT_GRAPH_TENANT_ID_ANNOTATION];
+    retrieveItems(groupMember, id).forEach((m) => {
+      const childGroup = groupMap.get(m);
+      if (childGroup) {
+        group.spec.children.push(catalogModel.stringifyEntityRef(childGroup));
+      }
+    });
+    retrieveItems(parentGroups, id).forEach((p) => {
+      const parentGroup = groupMap.get(p);
+      if (parentGroup) {
+        group.spec.parent = catalogModel.stringifyEntityRef(parentGroup);
+      }
+    });
+  });
+  buildOrgHierarchy(groups);
+  users.forEach((user) => {
+    const id = user.metadata.annotations[MICROSOFT_GRAPH_USER_ID_ANNOTATION];
+    retrieveItems(groupMemberOf, id).forEach((p) => {
+      const parentGroup = groupMap.get(p);
+      if (parentGroup) {
+        if (!user.spec.memberOf) {
+          user.spec.memberOf = [];
+        }
+        user.spec.memberOf.push(catalogModel.stringifyEntityRef(parentGroup));
+      }
+    });
+  });
+  buildMemberOf(groups, users);
+}
+async function readMicrosoftGraphOrg(client, tenantId, options) {
+  let users = [];
+  if (options.userGroupMemberFilter || options.userGroupMemberSearch) {
+    const { users: usersInGroups } = await readMicrosoftGraphUsersInGroups(
+      client,
+      {
+        queryMode: options.queryMode,
+        userExpand: options.userExpand,
+        userFilter: options.userFilter,
+        userSelect: options.userSelect,
+        userGroupMemberFilter: options.userGroupMemberFilter,
+        userGroupMemberSearch: options.userGroupMemberSearch,
+        loadUserPhotos: options.loadUserPhotos,
+        transformer: options.userTransformer,
+        logger: options.logger
+      }
+    );
+    users = usersInGroups;
+  } else {
+    const { users: usersWithFilter } = await readMicrosoftGraphUsers(client, {
+      queryMode: options.queryMode,
+      userExpand: options.userExpand,
+      userFilter: options.userFilter,
+      userSelect: options.userSelect,
+      loadUserPhotos: options.loadUserPhotos,
+      transformer: options.userTransformer,
+      logger: options.logger
+    });
+    users = usersWithFilter;
+  }
+  const { groups, rootGroup, groupMember, groupMemberOf } = await readMicrosoftGraphGroups(client, tenantId, {
+    queryMode: options.queryMode,
+    groupExpand: options.groupExpand,
+    groupFilter: options.groupFilter,
+    groupSearch: options.groupSearch,
+    groupSelect: options.groupSelect,
+    groupTransformer: options.groupTransformer,
+    organizationTransformer: options.organizationTransformer
+  });
+  resolveRelations(rootGroup, groups, users, groupMember, groupMemberOf);
+  users.sort((a, b) => a.metadata.name.localeCompare(b.metadata.name));
+  groups.sort((a, b) => a.metadata.name.localeCompare(b.metadata.name));
+  return { users, groups };
+}
+async function transformUsers(client, users, logger, loadUserPhotos = true, transformer) {
+  const limiter = limiterFactory__default.default(10);
+  const resolvedTransformer = transformer ?? defaultUserTransformer;
+  const promises = [];
+  const entities = [];
+  for await (const user of users) {
+    promises.push(
+      limiter(async () => {
+        let userPhoto;
+        try {
+          if (loadUserPhotos) {
+            userPhoto = await client.getUserPhotoWithSizeLimit(
+              user.id,
+              // We are limiting the photo size, as users with full resolution photos
+              // can make the Backstage API slow
+              120
+            );
+          }
+        } catch (e) {
+          logger.warn(`Unable to load user photo for`, {
+            user: user.id,
+            error: e
+          });
+        }
+        const entity = await resolvedTransformer(user, userPhoto);
+        if (entity) {
+          entities.push(entity);
+        }
+      })
+    );
+  }
+  await Promise.all(promises);
+  logger.debug("Finished transforming users", {
+    microsoftUserCount: promises.length,
+    backstageUserCount: entities.length
+  });
+  return entities;
+}
+function ensureItem(target, key, value) {
+  let set = target.get(key);
+  if (!set) {
+    set = /* @__PURE__ */ new Set();
+    target.set(key, set);
+  }
+  set.add(value);
+}
+function retrieveItems(target, key) {
+  return target.get(key) ?? /* @__PURE__ */ new Set();
+}
+
+class MicrosoftGraphOrgEntityProvider {
+  constructor(options) {
+    this.options = options;
+  }
+  connection;
+  scheduleFn;
+  static fromConfig(configRoot, options) {
+    if ("id" in options) {
+      return [
+        MicrosoftGraphOrgEntityProvider.fromLegacyConfig(configRoot, options)
+      ];
+    }
+    if (!options.schedule && !options.scheduler) {
+      throw new Error("Either schedule or scheduler must be provided.");
+    }
+    function getTransformer(id, transformers) {
+      if (["undefined", "function"].includes(typeof transformers)) {
+        return transformers;
+      }
+      return transformers[id];
+    }
+    return readProviderConfigs(configRoot).map((providerConfig) => {
+      if (!options.schedule && !providerConfig.schedule) {
+        throw new Error(
+          `No schedule provided neither via code nor config for MicrosoftGraphOrgEntityProvider:${providerConfig.id}.`
+        );
+      }
+      const taskRunner = options.schedule ?? options.scheduler.createScheduledTaskRunner(providerConfig.schedule);
+      const provider = new MicrosoftGraphOrgEntityProvider({
+        id: providerConfig.id,
+        provider: providerConfig,
+        logger: options.logger,
+        userTransformer: getTransformer(
+          providerConfig.id,
+          options.userTransformer
+        ),
+        groupTransformer: getTransformer(
+          providerConfig.id,
+          options.groupTransformer
+        ),
+        organizationTransformer: getTransformer(
+          providerConfig.id,
+          options.organizationTransformer
+        ),
+        providerConfigTransformer: getTransformer(
+          providerConfig.id,
+          options.providerConfigTransformer
+        )
+      });
+      if (taskRunner !== "manual") {
+        provider.schedule(taskRunner);
+      }
+      return provider;
+    });
+  }
+  /**
+   * @deprecated Exists for backwards compatibility only and will be removed in the future.
+   */
+  static fromLegacyConfig(configRoot, options) {
+    options.logger.warn(
+      'Deprecated msgraph config "catalog.processors.microsoftGraphOrg" used. Use "catalog.providers.microsoftGraphOrg" instead. More info at https://github.com/backstage/backstage/blob/master/plugins/catalog-backend-module-msgraph/CHANGELOG.md#040-next1'
+    );
+    const config = configRoot.getOptionalConfig(
+      "catalog.processors.microsoftGraphOrg"
+    );
+    const providers = config ? readMicrosoftGraphConfig(config) : [];
+    const provider = providers.find((p) => options.target.startsWith(p.target));
+    if (!provider) {
+      throw new Error(
+        `There is no Microsoft Graph Org provider that matches "${options.target}". Please add a configuration entry for it under "catalog.processors.microsoftGraphOrg.providers".`
+      );
+    }
+    const logger = options.logger.child({
+      target: options.target
+    });
+    const result = new MicrosoftGraphOrgEntityProvider({
+      id: options.id,
+      userTransformer: options.userTransformer,
+      groupTransformer: options.groupTransformer,
+      organizationTransformer: options.organizationTransformer,
+      providerConfigTransformer: options.providerConfigTransformer,
+      logger,
+      provider
+    });
+    if (options.schedule !== "manual") {
+      result.schedule(options.schedule);
+    }
+    return result;
+  }
+  /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.getProviderName} */
+  getProviderName() {
+    return `MicrosoftGraphOrgEntityProvider:${this.options.id}`;
+  }
+  /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.connect} */
+  async connect(connection) {
+    this.connection = connection;
+    await this.scheduleFn?.();
+  }
+  /**
+   * Runs one complete ingestion loop. Call this method regularly at some
+   * appropriate cadence.
+   */
+  async read(options) {
+    if (!this.connection) {
+      throw new Error("Not initialized");
+    }
+    const logger = options?.logger ?? this.options.logger;
+    const provider = this.options.providerConfigTransformer ? await this.options.providerConfigTransformer(this.options.provider) : this.options.provider;
+    const { markReadComplete } = trackProgress(logger);
+    const client = MicrosoftGraphClient.create(this.options.provider);
+    const { users, groups } = await readMicrosoftGraphOrg(
+      client,
+      provider.tenantId,
+      {
+        userExpand: provider.userExpand,
+        userFilter: provider.userFilter,
+        userSelect: provider.userSelect,
+        loadUserPhotos: provider.loadUserPhotos,
+        userGroupMemberFilter: provider.userGroupMemberFilter,
+        userGroupMemberSearch: provider.userGroupMemberSearch,
+        groupExpand: provider.groupExpand,
+        groupFilter: provider.groupFilter,
+        groupSearch: provider.groupSearch,
+        groupSelect: provider.groupSelect,
+        queryMode: provider.queryMode,
+        groupTransformer: this.options.groupTransformer,
+        userTransformer: this.options.userTransformer,
+        organizationTransformer: this.options.organizationTransformer,
+        logger
+      }
+    );
+    const { markCommitComplete } = markReadComplete({ users, groups });
+    await this.connection.applyMutation({
+      type: "full",
+      entities: [...users, ...groups].map((entity) => ({
+        locationKey: `msgraph-org-provider:${this.options.id}`,
+        entity: withLocations(this.options.id, entity)
+      }))
+    });
+    markCommitComplete();
+  }
+  schedule(taskRunner) {
+    this.scheduleFn = async () => {
+      const id = `${this.getProviderName()}:refresh`;
+      await taskRunner.run({
+        id,
+        fn: async () => {
+          const logger = this.options.logger.child({
+            class: MicrosoftGraphOrgEntityProvider.prototype.constructor.name,
+            taskId: id,
+            taskInstanceId: uuid__namespace.v4()
+          });
+          try {
+            await this.read({ logger });
+          } catch (error) {
+            logger.error(
+              `${this.getProviderName()} refresh failed, ${error}`,
+              error
+            );
+          }
+        }
+      });
+    };
+  }
+}
+function trackProgress(logger) {
+  let timestamp = Date.now();
+  let summary;
+  logger.info("Reading msgraph users and groups");
+  function markReadComplete(read) {
+    summary = `${read.users.length} msgraph users and ${read.groups.length} msgraph groups`;
+    const readDuration = ((Date.now() - timestamp) / 1e3).toFixed(1);
+    timestamp = Date.now();
+    logger.info(`Read ${summary} in ${readDuration} seconds. Committing...`);
+    return { markCommitComplete };
+  }
+  function markCommitComplete() {
+    const commitDuration = ((Date.now() - timestamp) / 1e3).toFixed(1);
+    logger.info(`Committed ${summary} in ${commitDuration} seconds.`);
+  }
+  return { markReadComplete };
+}
+function withLocations(providerId, entity) {
+  const uid = entity.metadata.annotations?.[MICROSOFT_GRAPH_USER_ID_ANNOTATION] || entity.metadata.annotations?.[MICROSOFT_GRAPH_GROUP_ID_ANNOTATION] || entity.metadata.annotations?.[MICROSOFT_GRAPH_TENANT_ID_ANNOTATION] || entity.metadata.name;
+  const location = `msgraph:${providerId}/${encodeURIComponent(uid)}`;
+  return lodash.merge(
+    {
+      metadata: {
+        annotations: {
+          [catalogModel.ANNOTATION_LOCATION]: location,
+          [catalogModel.ANNOTATION_ORIGIN_LOCATION]: location
+        }
+      }
+    },
+    entity
+  );
+}
+
+exports.MICROSOFT_EMAIL_ANNOTATION = MICROSOFT_EMAIL_ANNOTATION;
+exports.MICROSOFT_GRAPH_GROUP_ID_ANNOTATION = MICROSOFT_GRAPH_GROUP_ID_ANNOTATION;
+exports.MICROSOFT_GRAPH_TENANT_ID_ANNOTATION = MICROSOFT_GRAPH_TENANT_ID_ANNOTATION;
+exports.MICROSOFT_GRAPH_USER_ID_ANNOTATION = MICROSOFT_GRAPH_USER_ID_ANNOTATION;
+exports.MicrosoftGraphClient = MicrosoftGraphClient;
+exports.MicrosoftGraphOrgEntityProvider = MicrosoftGraphOrgEntityProvider;
+exports.defaultGroupTransformer = defaultGroupTransformer;
+exports.defaultOrganizationTransformer = defaultOrganizationTransformer;
+exports.defaultUserTransformer = defaultUserTransformer;
+exports.normalizeEntityName = normalizeEntityName;
+exports.readMicrosoftGraphConfig = readMicrosoftGraphConfig;
+exports.readMicrosoftGraphOrg = readMicrosoftGraphOrg;
+exports.readProviderConfig = readProviderConfig;
+exports.readProviderConfigs = readProviderConfigs;
+//# sourceMappingURL=MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js.map
diff --git a/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/cjs/MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js.map b/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/cjs/MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js.map
new file mode 100644
index 0000000..b8dbe27
--- /dev/null
+++ b/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/cjs/MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js","sources":["../../src/microsoftGraph/client.ts","../../src/microsoftGraph/config.ts","../../src/microsoftGraph/constants.ts","../../src/microsoftGraph/helper.ts","../../src/microsoftGraph/defaultTransformers.ts","../../src/microsoftGraph/org.ts","../../src/microsoftGraph/read.ts","../../src/processors/MicrosoftGraphOrgEntityProvider.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  TokenCredential,\n  DefaultAzureCredential,\n  ClientSecretCredential,\n} from '@azure/identity';\nimport * as MicrosoftGraph from '@microsoft/microsoft-graph-types';\nimport fetch, { Response } from 'node-fetch';\nimport qs from 'qs';\nimport { MicrosoftGraphProviderConfig } from './config';\n\n/**\n * OData (Open Data Protocol) Query\n *\n * {@link https://docs.microsoft.com/en-us/odata/concepts/queryoptions-overview}\n * {@link https://docs.microsoft.com/en-us/graph/query-parameters}\n * @public\n */\nexport type ODataQuery = {\n  /**\n   * search resources within a collection matching a free-text search expression.\n   */\n  search?: string;\n  /**\n   * filter a collection of resources\n   */\n  filter?: string;\n  /**\n   * specifies the related resources or media streams to be included in line with retrieved resources\n   */\n  expand?: string;\n  /**\n   * request a specific set of properties for each entity or complex type\n   */\n  select?: string[];\n  /**\n   * Retrieves the total count of matching resources.\n   */\n  count?: boolean;\n  /**\n   * Maximum number of records to receive in one batch.\n   */\n  top?: number;\n};\n\n/**\n * Extends the base msgraph types to include the odata type.\n *\n * @public\n */\nexport type GroupMember =\n  | (MicrosoftGraph.Group & { '@odata.type': '#microsoft.graph.user' })\n  | (MicrosoftGraph.User & { '@odata.type': '#microsoft.graph.group' });\n\n/**\n * A HTTP Client that communicates with Microsoft Graph API.\n * Simplify Authentication and API calls to get `User` and `Group` from Microsoft Graph\n *\n * Uses `msal-node` for authentication\n *\n * @public\n */\nexport class MicrosoftGraphClient {\n  /**\n   * Factory method that instantiate `msal` client and return\n   * an instance of `MicrosoftGraphClient`\n   *\n   * @public\n   *\n   * @param config - Configuration for Interacting with Graph API\n   */\n  static create(config: MicrosoftGraphProviderConfig): MicrosoftGraphClient {\n    const options = {\n      authorityHost: config.authority,\n      tenantId: config.tenantId,\n    };\n\n    const credential =\n      config.clientId && config.clientSecret\n        ? new ClientSecretCredential(\n            config.tenantId,\n            config.clientId,\n            config.clientSecret,\n            options,\n          )\n        : new DefaultAzureCredential(options);\n\n    return new MicrosoftGraphClient(config.target, credential);\n  }\n\n  /**\n   * @param baseUrl - baseUrl of Graph API {@link MicrosoftGraphProviderConfig.target}\n   * @param tokenCredential - instance of `TokenCredential` that is used to acquire token for Graph API calls\n   *\n   */\n  constructor(\n    private readonly baseUrl: string,\n    private readonly tokenCredential: TokenCredential,\n  ) {}\n\n  /**\n   * Get a collection of resource from Graph API and\n   * return an `AsyncIterable` of that resource\n   *\n   * @public\n   * @param path - Resource in Microsoft Graph\n   * @param query - OData Query {@link ODataQuery}\n   * @param queryMode - Mode to use while querying. Some features are only available at \"advanced\".\n   */\n  async *requestCollection<T>(\n    path: string,\n    query?: ODataQuery,\n    queryMode?: 'basic' | 'advanced',\n  ): AsyncIterable<T> {\n    // upgrade to advanced query mode transparently when \"search\" is used\n    // to stay backwards compatible.\n    const appliedQueryMode = query?.search ? 'advanced' : queryMode ?? 'basic';\n\n    // not needed for \"search\"\n    // as of https://docs.microsoft.com/en-us/graph/aad-advanced-queries?tabs=http\n    // even though a few other places say the opposite\n    // - https://docs.microsoft.com/en-us/graph/api/user-list?view=graph-rest-1.0&tabs=http#request-headers\n    // - https://docs.microsoft.com/en-us/graph/api/resources/group?view=graph-rest-1.0#properties\n    if (appliedQueryMode === 'advanced' && (query?.filter || query?.select)) {\n      query.count = true;\n    }\n    const headers: Record<string, string> =\n      appliedQueryMode === 'advanced'\n        ? {\n            // Eventual consistency is required for advanced querying capabilities\n            // like \"$search\" or parts of \"$filter\".\n            // If a new user/group is not found, it'll eventually be imported on a subsequent read\n            ConsistencyLevel: 'eventual',\n          }\n        : {};\n\n    let response = await this.requestApi(path, query, headers);\n\n    for (;;) {\n      if (response.status !== 200) {\n        await this.handleError(path, response);\n      }\n\n      const result = await response.json();\n\n      // Graph API return array of collections\n      const elements: T[] = result.value;\n\n      yield* elements;\n\n      // Follow cursor to the next page if one is available\n      if (!result['@odata.nextLink']) {\n        return;\n      }\n\n      response = await this.requestRaw(result['@odata.nextLink'], headers);\n    }\n  }\n\n  /**\n   * Abstract on top of {@link MicrosoftGraphClient.requestRaw}\n   *\n   * @public\n   * @param path - Resource in Microsoft Graph\n   * @param query - OData Query {@link ODataQuery}\n   * @param headers - optional HTTP headers\n   */\n  async requestApi(\n    path: string,\n    query?: ODataQuery,\n    headers?: Record<string, string>,\n  ): Promise<Response> {\n    const queryString = qs.stringify(\n      {\n        $search: query?.search,\n        $filter: query?.filter,\n        $select: query?.select?.join(','),\n        $expand: query?.expand,\n        $count: query?.count,\n        $top: query?.top,\n      },\n      {\n        addQueryPrefix: true,\n        // Microsoft Graph doesn't like an encoded query string\n        encode: false,\n      },\n    );\n\n    return await this.requestRaw(\n      `${this.baseUrl}/${path}${queryString}`,\n      headers,\n    );\n  }\n\n  /**\n   * Makes a HTTP call to Graph API with token\n   *\n   * @param url - HTTP Endpoint of Graph API\n   * @param headers - optional HTTP headers\n   */\n  async requestRaw(\n    url: string,\n    headers?: Record<string, string>,\n    retryCount = 2,\n  ): Promise<Response> {\n    // Make sure that we always have a valid access token (might be cached)\n    const urlObj = new URL(url);\n    const token = await this.tokenCredential.getToken(\n      `${urlObj.protocol}//${urlObj.hostname}/.default`,\n    );\n\n    if (!token) {\n      throw new Error('Failed to obtain token from Azure Identity');\n    }\n\n    try {\n      return await fetch(url, {\n        headers: {\n          ...headers,\n          Authorization: `Bearer ${token.token}`,\n        },\n      });\n    } catch (e: any) {\n      if (e?.code === 'ETIMEDOUT' && retryCount > 0) {\n        return this.requestRaw(url, headers, retryCount - 1);\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Get {@link https://docs.microsoft.com/en-us/graph/api/resources/profilephoto | profilePhoto}\n   * of `User` from Graph API with size limit\n   *\n   * @param userId - The unique identifier for the `User` resource\n   * @param maxSize - Maximum pixel height of the photo\n   *\n   */\n  async getUserPhotoWithSizeLimit(\n    userId: string,\n    maxSize: number,\n  ): Promise<string | undefined> {\n    return await this.getPhotoWithSizeLimit('users', userId, maxSize);\n  }\n\n  async getUserPhoto(\n    userId: string,\n    sizeId?: string,\n  ): Promise<string | undefined> {\n    return await this.getPhoto('users', userId, sizeId);\n  }\n\n  /**\n   * Get a collection of\n   * {@link https://docs.microsoft.com/en-us/graph/api/resources/user | User}\n   * from Graph API and return as `AsyncIterable`\n   *\n   * @public\n   * @param query - OData Query {@link ODataQuery}\n   * @param queryMode - Mode to use while querying. Some features are only available at \"advanced\".\n   */\n  async *getUsers(\n    query?: ODataQuery,\n    queryMode?: 'basic' | 'advanced',\n  ): AsyncIterable<MicrosoftGraph.User> {\n    yield* this.requestCollection<MicrosoftGraph.User>(\n      `users`,\n      query,\n      queryMode,\n    );\n  }\n\n  /**\n   * Get {@link https://docs.microsoft.com/en-us/graph/api/resources/profilephoto | profilePhoto}\n   * of `Group` from Graph API with size limit\n   *\n   * @param groupId - The unique identifier for the `Group` resource\n   * @param maxSize - Maximum pixel height of the photo\n   *\n   */\n  async getGroupPhotoWithSizeLimit(\n    groupId: string,\n    maxSize: number,\n  ): Promise<string | undefined> {\n    return await this.getPhotoWithSizeLimit('groups', groupId, maxSize);\n  }\n\n  async getGroupPhoto(\n    groupId: string,\n    sizeId?: string,\n  ): Promise<string | undefined> {\n    return await this.getPhoto('groups', groupId, sizeId);\n  }\n\n  /**\n   * Get a collection of\n   * {@link https://docs.microsoft.com/en-us/graph/api/resources/group | Group}\n   * from Graph API and return as `AsyncIterable`\n   *\n   * @public\n   * @param query - OData Query {@link ODataQuery}\n   * @param queryMode - Mode to use while querying. Some features are only available at \"advanced\".\n   */\n  async *getGroups(\n    query?: ODataQuery,\n    queryMode?: 'basic' | 'advanced',\n  ): AsyncIterable<MicrosoftGraph.Group> {\n    yield* this.requestCollection<MicrosoftGraph.Group>(\n      `groups`,\n      query,\n      queryMode,\n    );\n  }\n\n  /**\n   * Get a collection of\n   * {@link https://docs.microsoft.com/en-us/graph/api/resources/user | User}\n   * belonging to a `Group` from Graph API and return as `AsyncIterable`\n   * @public\n   * @param groupId - The unique identifier for the `Group` resource\n   *\n   */\n  async *getGroupMembers(\n    groupId: string,\n    query?: ODataQuery,\n    queryMode?: 'basic' | 'advanced',\n  ): AsyncIterable<GroupMember> {\n    yield* this.requestCollection<GroupMember>(\n      `groups/${groupId}/members`,\n      query,\n      queryMode,\n    );\n  }\n\n  /**\n   * Get a collection of\n   * {@link https://docs.microsoft.com/en-us/graph/api/resources/user | User}\n   * belonging to a `Group` from Graph API and return as `AsyncIterable`\n   * @public\n   * @param groupId - The unique identifier for the `Group` resource\n   * @param query - OData Query {@link ODataQuery}\n   * @param queryMode - Mode to use while querying. Some features are only available at \"advanced\".\n   */\n  async *getGroupUserMembers(\n    groupId: string,\n    query?: ODataQuery,\n    queryMode?: 'basic' | 'advanced',\n  ): AsyncIterable<MicrosoftGraph.User> {\n    yield* this.requestCollection<MicrosoftGraph.User>(\n      `groups/${groupId}/members/microsoft.graph.user/`,\n      query,\n      queryMode,\n    );\n  }\n\n  /**\n   * Get {@link https://docs.microsoft.com/en-us/graph/api/resources/organization | Organization}\n   * from Graph API\n   * @public\n   * @param tenantId - The unique identifier for the `Organization` resource\n   *\n   */\n  async getOrganization(\n    tenantId: string,\n  ): Promise<MicrosoftGraph.Organization> {\n    const response = await this.requestApi(`organization/${tenantId}`);\n\n    if (response.status !== 200) {\n      await this.handleError(`organization/${tenantId}`, response);\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Get {@link https://docs.microsoft.com/en-us/graph/api/resources/profilephoto | profilePhoto}\n   * from Graph API\n   *\n   * @param entityName - type of parent resource, either `User` or `Group`\n   * @param id - The unique identifier for the {@link entityName | entityName} resource\n   * @param maxSize - Maximum pixel height of the photo\n   *\n   */\n  private async getPhotoWithSizeLimit(\n    entityName: string,\n    id: string,\n    maxSize: number,\n  ): Promise<string | undefined> {\n    const response = await this.requestApi(`${entityName}/${id}/photos`);\n\n    if (response.status === 404) {\n      return undefined;\n    } else if (response.status !== 200) {\n      await this.handleError(`${entityName} photos`, response);\n    }\n\n    const result = await response.json();\n    const photos = result.value as MicrosoftGraph.ProfilePhoto[];\n    let selectedPhoto: MicrosoftGraph.ProfilePhoto | undefined = undefined;\n\n    // Find the biggest picture that is smaller than the max size\n    for (const p of photos) {\n      if (\n        !selectedPhoto ||\n        (p.height! >= selectedPhoto.height! && p.height! <= maxSize)\n      ) {\n        selectedPhoto = p;\n      }\n    }\n\n    if (!selectedPhoto) {\n      return undefined;\n    }\n\n    return await this.getPhoto(entityName, id, selectedPhoto.id!);\n  }\n\n  private async getPhoto(\n    entityName: string,\n    id: string,\n    sizeId?: string,\n  ): Promise<string | undefined> {\n    const path = sizeId\n      ? `${entityName}/${id}/photos/${sizeId}/$value`\n      : `${entityName}/${id}/photo/$value`;\n    const response = await this.requestApi(path);\n\n    if (response.status === 404) {\n      return undefined;\n    } else if (response.status !== 200) {\n      await this.handleError('photo', response);\n    }\n\n    return `data:image/jpeg;base64,${Buffer.from(\n      await response.arrayBuffer(),\n    ).toString('base64')}`;\n  }\n\n  private async handleError(path: string, response: Response): Promise<void> {\n    const result = await response.json();\n    const error = result.error as MicrosoftGraph.PublicError;\n\n    throw new Error(\n      `Error while reading ${path} from Microsoft Graph: ${error.code} - ${error.message}`,\n    );\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  readTaskScheduleDefinitionFromConfig,\n  TaskScheduleDefinition,\n} from '@backstage/backend-tasks';\nimport { Config } from '@backstage/config';\nimport { trimEnd } from 'lodash';\n\nconst DEFAULT_PROVIDER_ID = 'default';\nconst DEFAULT_TARGET = 'https://graph.microsoft.com/v1.0';\n\n/**\n * The configuration parameters for a single Microsoft Graph provider.\n *\n * @public\n */\nexport type MicrosoftGraphProviderConfig = {\n  /**\n   * Identifier of the provider which will be used i.e. at the location key for ingested entities.\n   */\n  id: string;\n\n  /**\n   * The prefix of the target that this matches on, e.g.\n   * \"https://graph.microsoft.com/v1.0\", with no trailing slash.\n   */\n  target: string;\n  /**\n   * The auth authority used.\n   *\n   * E.g. \"https://login.microsoftonline.com\"\n   */\n  authority?: string;\n  /**\n   * The tenant whose org data we are interested in.\n   */\n  tenantId: string;\n  /**\n   * The OAuth client ID to use for authenticating requests.\n   * If specified, ClientSecret must also be specified\n   */\n  clientId?: string;\n  /**\n   * The OAuth client secret to use for authenticating requests.\n   * If specified, ClientId must also be specified\n   */\n  clientSecret?: string;\n  /**\n   * The filter to apply to extract users.\n   *\n   * E.g. \"accountEnabled eq true and userType eq 'member'\"\n   */\n  userFilter?: string;\n  /**\n   * The fields to be fetched on query.\n   *\n   * E.g. [\"id\", \"displayName\", \"description\"]\n   */\n  userSelect?: string[];\n  /**\n   * The \"expand\" argument to apply to users.\n   *\n   * E.g. \"manager\".\n   */\n  userExpand?: string;\n  /**\n   * The filter to apply to extract users by groups memberships.\n   *\n   * E.g. \"displayName eq 'Backstage Users'\"\n   */\n  userGroupMemberFilter?: string;\n  /**\n   * The search criteria to apply to extract users by groups memberships.\n   *\n   * E.g. \"\\\"displayName:-team\\\"\" would only match groups which contain '-team'\n   */\n  userGroupMemberSearch?: string;\n  /**\n   * The \"expand\" argument to apply to groups.\n   *\n   * E.g. \"member\".\n   */\n  groupExpand?: string;\n  /**\n   * The filter to apply to extract groups.\n   *\n   * E.g. \"securityEnabled eq false and mailEnabled eq true\"\n   */\n  groupFilter?: string;\n  /**\n   * The search criteria to apply to extract groups.\n   *\n   * E.g. \"\\\"displayName:-team\\\"\" would only match groups which contain '-team'\n   */\n  groupSearch?: string;\n\n  /**\n   * The fields to be fetched on query.\n   *\n   * E.g. [\"id\", \"displayName\", \"description\"]\n   */\n  groupSelect?: string[];\n\n  /**\n   * By default, the Microsoft Graph API only provides the basic feature set\n   * for querying. Certain features are limited to advanced query capabilities\n   * (see https://docs.microsoft.com/en-us/graph/aad-advanced-queries)\n   * and need to be enabled.\n   *\n   * Some features like `$expand` are not available for advanced queries, though.\n   */\n  queryMode?: 'basic' | 'advanced';\n\n  /**\n   * Set to false to not load user photos.\n   * This can be useful for huge organizations.\n   */\n  loadUserPhotos?: boolean;\n\n  /**\n   * Schedule configuration for refresh tasks.\n   */\n  schedule?: TaskScheduleDefinition;\n};\n\n/**\n * Parses configuration.\n *\n * @param config - The root of the msgraph config hierarchy\n *\n * @public\n * @deprecated Replaced by not exported `readProviderConfigs` and kept for backwards compatibility only.\n */\nexport function readMicrosoftGraphConfig(\n  config: Config,\n): MicrosoftGraphProviderConfig[] {\n  const providers: MicrosoftGraphProviderConfig[] = [];\n  const providerConfigs = config.getOptionalConfigArray('providers') ?? [];\n\n  for (const providerConfig of providerConfigs) {\n    const target = trimEnd(\n      providerConfig.getOptionalString('target') ?? DEFAULT_TARGET,\n      '/',\n    );\n    const authority = providerConfig.getOptionalString('authority');\n\n    const tenantId = providerConfig.getString('tenantId');\n    const clientId = providerConfig.getOptionalString('clientId');\n    const clientSecret = providerConfig.getOptionalString('clientSecret');\n\n    const userExpand = providerConfig.getOptionalString('userExpand');\n    const userFilter = providerConfig.getOptionalString('userFilter');\n    const userSelect = providerConfig.getOptionalStringArray('userSelect');\n    const userGroupMemberFilter = providerConfig.getOptionalString(\n      'userGroupMemberFilter',\n    );\n    const userGroupMemberSearch = providerConfig.getOptionalString(\n      'userGroupMemberSearch',\n    );\n    const groupExpand = providerConfig.getOptionalString('groupExpand');\n    const groupFilter = providerConfig.getOptionalString('groupFilter');\n    const groupSearch = providerConfig.getOptionalString('groupSearch');\n\n    if (userFilter && userGroupMemberFilter) {\n      throw new Error(\n        `userFilter and userGroupMemberFilter are mutually exclusive, only one can be specified.`,\n      );\n    }\n    if (userFilter && userGroupMemberSearch) {\n      throw new Error(\n        `userGroupMemberSearch cannot be specified when userFilter is defined.`,\n      );\n    }\n\n    const groupSelect = providerConfig.getOptionalStringArray('groupSelect');\n    const queryMode = providerConfig.getOptionalString('queryMode');\n    if (\n      queryMode !== undefined &&\n      queryMode !== 'basic' &&\n      queryMode !== 'advanced'\n    ) {\n      throw new Error(`queryMode must be one of: basic, advanced`);\n    }\n\n    if (clientId && !clientSecret) {\n      throw new Error(\n        `clientSecret must be provided when clientId is defined.`,\n      );\n    }\n\n    if (clientSecret && !clientId) {\n      throw new Error(\n        `clientId must be provided when clientSecret is defined.`,\n      );\n    }\n\n    providers.push({\n      id: target,\n      target,\n      authority,\n      tenantId,\n      clientId,\n      clientSecret,\n      userExpand,\n      userFilter,\n      userSelect,\n      userGroupMemberFilter,\n      userGroupMemberSearch,\n      groupExpand,\n      groupFilter,\n      groupSearch,\n      groupSelect,\n      queryMode,\n    });\n  }\n\n  return providers;\n}\n\n/**\n * Parses all configured providers.\n *\n * @param config - The root of the msgraph config hierarchy\n *\n * @public\n */\nexport function readProviderConfigs(\n  config: Config,\n): MicrosoftGraphProviderConfig[] {\n  const providersConfig = config.getOptionalConfig(\n    'catalog.providers.microsoftGraphOrg',\n  );\n  if (!providersConfig) {\n    return [];\n  }\n\n  if (providersConfig.has('clientId')) {\n    // simple/single config variant\n    return [readProviderConfig(DEFAULT_PROVIDER_ID, providersConfig)];\n  }\n\n  return providersConfig.keys().map(id => {\n    const providerConfig = providersConfig.getConfig(id);\n\n    return readProviderConfig(id, providerConfig);\n  });\n}\n\n/**\n * Parses a single configured provider by id.\n *\n * @param id - the id of the provider to parse\n * @param config - The root of the msgraph config hierarchy\n *\n * @public\n */\nexport function readProviderConfig(\n  id: string,\n  config: Config,\n): MicrosoftGraphProviderConfig {\n  const target = trimEnd(\n    config.getOptionalString('target') ?? DEFAULT_TARGET,\n    '/',\n  );\n  const authority = config.getOptionalString('authority');\n\n  const tenantId = config.getString('tenantId');\n  const clientId = config.getOptionalString('clientId');\n  const clientSecret = config.getOptionalString('clientSecret');\n\n  const userExpand = config.getOptionalString('user.expand');\n  const userFilter = config.getOptionalString('user.filter');\n  const userSelect = config.getOptionalStringArray('user.select');\n  const loadUserPhotos = config.getOptionalBoolean('user.loadPhotos');\n\n  const groupExpand = config.getOptionalString('group.expand');\n  const groupFilter = config.getOptionalString('group.filter');\n  const groupSearch = config.getOptionalString('group.search');\n  const groupSelect = config.getOptionalStringArray('group.select');\n\n  const queryMode = config.getOptionalString('queryMode');\n  if (\n    queryMode !== undefined &&\n    queryMode !== 'basic' &&\n    queryMode !== 'advanced'\n  ) {\n    throw new Error(`queryMode must be one of: basic, advanced`);\n  }\n\n  const userGroupMemberFilter = config.getOptionalString(\n    'userGroupMember.filter',\n  );\n  const userGroupMemberSearch = config.getOptionalString(\n    'userGroupMember.search',\n  );\n\n  if (userFilter && userGroupMemberFilter) {\n    throw new Error(\n      `userFilter and userGroupMemberFilter are mutually exclusive, only one can be specified.`,\n    );\n  }\n  if (userFilter && userGroupMemberSearch) {\n    throw new Error(\n      `userGroupMemberSearch cannot be specified when userFilter is defined.`,\n    );\n  }\n\n  if (clientId && !clientSecret) {\n    throw new Error(`clientSecret must be provided when clientId is defined.`);\n  }\n\n  if (clientSecret && !clientId) {\n    throw new Error(`clientId must be provided when clientSecret is defined.`);\n  }\n\n  const schedule = config.has('schedule')\n    ? readTaskScheduleDefinitionFromConfig(config.getConfig('schedule'))\n    : undefined;\n\n  return {\n    id,\n    target,\n    authority,\n    clientId,\n    clientSecret,\n    tenantId,\n    userExpand,\n    userFilter,\n    userSelect,\n    loadUserPhotos,\n    groupExpand,\n    groupFilter,\n    groupSearch,\n    groupSelect,\n    queryMode,\n    userGroupMemberFilter,\n    userGroupMemberSearch,\n    schedule,\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The (primary) user email. Also used by the Microsoft auth provider to resolve the User entity.\n *\n * @public\n */\nexport const MICROSOFT_EMAIL_ANNOTATION = 'microsoft.com/email';\n\n/**\n * The tenant id used by the Microsoft Graph API\n *\n * @public\n */\nexport const MICROSOFT_GRAPH_TENANT_ID_ANNOTATION =\n  'graph.microsoft.com/tenant-id';\n\n/**\n * The group id used by the Microsoft Graph API\n *\n * @public\n */\nexport const MICROSOFT_GRAPH_GROUP_ID_ANNOTATION =\n  'graph.microsoft.com/group-id';\n\n/**\n * The user id used by the Microsoft Graph API\n *\n * @public\n */\nexport const MICROSOFT_GRAPH_USER_ID_ANNOTATION = 'graph.microsoft.com/user-id';\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Takes an input string and cleans it up to become suitable as an entity name.\n *\n * @public\n */\nexport function normalizeEntityName(name: string): string {\n  let cleaned = name\n    .trim()\n    .toLocaleLowerCase()\n    .replace(/[^a-zA-Z0-9_\\-\\.]/g, '_');\n\n  // invalid to end with _\n  while (cleaned.endsWith('_')) {\n    cleaned = cleaned.substring(0, cleaned.length - 1);\n  }\n\n  // cleans up format for groups like 'my group (Reader)'\n  while (cleaned.includes('__')) {\n    // replaceAll from node.js >= 15\n    cleaned = cleaned.replace('__', '_');\n  }\n\n  return cleaned;\n}\n","/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  MICROSOFT_EMAIL_ANNOTATION,\n  MICROSOFT_GRAPH_GROUP_ID_ANNOTATION,\n  MICROSOFT_GRAPH_TENANT_ID_ANNOTATION,\n  MICROSOFT_GRAPH_USER_ID_ANNOTATION,\n} from './constants';\nimport { normalizeEntityName } from './helper';\nimport { GroupEntity, UserEntity } from '@backstage/catalog-model';\nimport * as MicrosoftGraph from '@microsoft/microsoft-graph-types';\n\n/**\n * The default implementation of the transformation from a graph organization\n * entry to a Group entity.\n *\n * @public\n */\nexport async function defaultOrganizationTransformer(\n  organization: MicrosoftGraph.Organization,\n): Promise<GroupEntity | undefined> {\n  if (!organization.id || !organization.displayName) {\n    return undefined;\n  }\n\n  const name = normalizeEntityName(organization.displayName!);\n  return {\n    apiVersion: 'backstage.io/v1alpha1',\n    kind: 'Group',\n    metadata: {\n      name: name,\n      description: organization.displayName!,\n      annotations: {\n        [MICROSOFT_GRAPH_TENANT_ID_ANNOTATION]: organization.id!,\n      },\n    },\n    spec: {\n      type: 'root',\n      profile: {\n        displayName: organization.displayName!,\n      },\n      children: [],\n    },\n  };\n}\n\nfunction extractGroupName(group: MicrosoftGraph.Group): string {\n  if (group.securityEnabled) {\n    return group.displayName as string;\n  }\n  return (group.mailNickname || group.displayName) as string;\n}\n\n/**\n * The default implementation of the transformation from a graph group entry to\n * a Group entity.\n *\n * @public\n */\nexport async function defaultGroupTransformer(\n  group: MicrosoftGraph.Group,\n  groupPhoto?: string,\n): Promise<GroupEntity | undefined> {\n  if (!group.id || !group.displayName) {\n    return undefined;\n  }\n\n  const name = normalizeEntityName(extractGroupName(group));\n  const entity: GroupEntity = {\n    apiVersion: 'backstage.io/v1alpha1',\n    kind: 'Group',\n    metadata: {\n      name: name,\n      annotations: {\n        [MICROSOFT_GRAPH_GROUP_ID_ANNOTATION]: group.id,\n      },\n    },\n    spec: {\n      type: 'team',\n      profile: {},\n      children: [],\n    },\n  };\n\n  if (group.description) {\n    entity.metadata.description = group.description;\n  }\n  if (group.displayName) {\n    entity.spec.profile!.displayName = group.displayName;\n  }\n  if (group.mail) {\n    entity.spec.profile!.email = group.mail;\n  }\n  if (groupPhoto) {\n    entity.spec.profile!.picture = groupPhoto;\n  }\n\n  return entity;\n}\n\n/**\n * The default implementation of the transformation from a graph user entry to\n * a User entity.\n *\n * @public\n */\nexport async function defaultUserTransformer(\n  user: MicrosoftGraph.User,\n  userPhoto?: string,\n): Promise<UserEntity | undefined> {\n  if (!user.id || !user.displayName) {\n    return undefined;\n  }\n\n  const name = user.mail\n    ? normalizeEntityName(user.mail)\n    : normalizeEntityName(user.userPrincipalName!);\n  const entity: UserEntity = {\n    apiVersion: 'backstage.io/v1alpha1',\n    kind: 'User',\n    metadata: {\n      name,\n      annotations: {\n        [MICROSOFT_GRAPH_USER_ID_ANNOTATION]: user.id!,\n      },\n    },\n    spec: {\n      profile: {\n        displayName: user.displayName!,\n\n        // TODO: Additional fields?\n        // jobTitle: user.jobTitle || undefined,\n        // officeLocation: user.officeLocation || undefined,\n        // mobilePhone: user.mobilePhone || undefined,\n      },\n      memberOf: [],\n    },\n  };\n\n  if (user.mail) {\n    entity.metadata.annotations![MICROSOFT_EMAIL_ANNOTATION] = user.mail;\n    entity.spec.profile!.email = user.mail;\n  }\n\n  if (userPhoto) {\n    entity.spec.profile!.picture = userPhoto;\n  }\n\n  return entity;\n}","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GroupEntity, UserEntity } from '@backstage/catalog-model';\n\n// TODO: Copied from plugin-catalog-backend, but we could also export them from\n// there. Or move them to catalog-model.\n\nexport function buildOrgHierarchy(groups: GroupEntity[]) {\n  const groupsByName = new Map(groups.map(g => [g.metadata.name, g]));\n\n  //\n  // Make sure that g.parent.children contain g\n  //\n\n  for (const group of groups) {\n    const selfName = group.metadata.name;\n    const parentName = group.spec.parent;\n    if (parentName) {\n      const parent = groupsByName.get(parentName);\n      if (parent && !parent.spec.children.includes(selfName)) {\n        parent.spec.children.push(selfName);\n      }\n    }\n  }\n\n  //\n  // Make sure that g.children.parent is g\n  //\n\n  for (const group of groups) {\n    const selfName = group.metadata.name;\n    for (const childName of group.spec.children) {\n      const child = groupsByName.get(childName);\n      if (child && !child.spec.parent) {\n        child.spec.parent = selfName;\n      }\n    }\n  }\n}\n\n// Ensure that users have their transitive group memberships. Requires that\n// the groups were previously processed with buildOrgHierarchy()\nexport function buildMemberOf(groups: GroupEntity[], users: UserEntity[]) {\n  const groupsByName = new Map(groups.map(g => [g.metadata.name, g]));\n\n  users.forEach(user => {\n    const transitiveMemberOf = new Set<string>();\n\n    const todo = [\n      ...(user.spec.memberOf ?? []),\n      ...groups\n        .filter(g => g.spec.members?.includes(user.metadata.name))\n        .map(g => g.metadata.name),\n    ];\n\n    for (;;) {\n      const current = todo.pop();\n      if (!current) {\n        break;\n      }\n\n      if (!transitiveMemberOf.has(current)) {\n        transitiveMemberOf.add(current);\n        const group = groupsByName.get(current);\n        if (group?.spec.parent) {\n          todo.push(group.spec.parent);\n        }\n      }\n    }\n\n    user.spec.memberOf = [...transitiveMemberOf];\n  });\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  GroupEntity,\n  stringifyEntityRef,\n  UserEntity,\n} from '@backstage/catalog-model';\nimport limiterFactory from 'p-limit';\nimport { MicrosoftGraphClient } from './client';\nimport {\n  MICROSOFT_GRAPH_GROUP_ID_ANNOTATION,\n  MICROSOFT_GRAPH_TENANT_ID_ANNOTATION,\n  MICROSOFT_GRAPH_USER_ID_ANNOTATION,\n} from './constants';\nimport { buildMemberOf, buildOrgHierarchy } from './org';\nimport {\n  GroupTransformer,\n  OrganizationTransformer,\n  UserTransformer,\n} from './types';\nimport {\n  defaultGroupTransformer,\n  defaultOrganizationTransformer,\n  defaultUserTransformer,\n} from './defaultTransformers';\nimport * as MicrosoftGraph from '@microsoft/microsoft-graph-types';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\nconst PAGE_SIZE = 999;\n\nexport async function readMicrosoftGraphUsers(\n  client: MicrosoftGraphClient,\n  options: {\n    queryMode?: 'basic' | 'advanced';\n    userExpand?: string;\n    userFilter?: string;\n    userSelect?: string[];\n    loadUserPhotos?: boolean;\n    transformer?: UserTransformer;\n    logger: LoggerService;\n  },\n): Promise<{\n  users: UserEntity[]; // With all relations empty\n}> {\n  const users = client.getUsers(\n    {\n      filter: options.userFilter,\n      expand: options.userExpand,\n      select: options.userSelect,\n      top: PAGE_SIZE,\n    },\n    options.queryMode,\n  );\n\n  return {\n    users: await transformUsers(\n      client,\n      users,\n      options.logger,\n      options.loadUserPhotos,\n      options.transformer,\n    ),\n  };\n}\n\nexport async function readMicrosoftGraphUsersInGroups(\n  client: MicrosoftGraphClient,\n  options: {\n    queryMode?: 'basic' | 'advanced';\n    userExpand?: string;\n    userFilter?: string;\n    userSelect?: string[];\n    loadUserPhotos?: boolean;\n    userGroupMemberSearch?: string;\n    userGroupMemberFilter?: string;\n    groupExpand?: string;\n    transformer?: UserTransformer;\n    logger: LoggerService;\n  },\n): Promise<{\n  users: UserEntity[]; // With all relations empty\n}> {\n  const limiter = limiterFactory(10);\n\n  const userGroupMemberPromises: Promise<void>[] = [];\n  const userGroupMembers = new Map<string, MicrosoftGraph.User>();\n\n  for await (const group of client.getGroups(\n    {\n      expand: options.groupExpand,\n      filter: options.userGroupMemberFilter,\n      search: options.userGroupMemberSearch,\n      select: ['id', 'displayName'],\n      top: PAGE_SIZE,\n    },\n    options.queryMode,\n  )) {\n    // Process all groups in parallel, otherwise it can take quite some time\n    userGroupMemberPromises.push(\n      limiter(async () => {\n        let groupMemberCount = 0;\n        for await (const user of client.getGroupUserMembers(\n          group.id!,\n          {\n            expand: options.userExpand,\n            filter: options.userFilter,\n            select: options.userSelect,\n            top: PAGE_SIZE,\n          },\n          options.queryMode,\n        )) {\n          userGroupMembers.set(user.id!, user);\n          groupMemberCount++;\n        }\n        options.logger.debug('Read users from group', {\n          groupId: group.id,\n          groupName: group.displayName,\n          memberCount: groupMemberCount,\n        });\n      }),\n    );\n  }\n\n  // Wait for all group members\n  await Promise.all(userGroupMemberPromises);\n\n  options.logger.info('Read users from group membership', {\n    groupCount: userGroupMemberPromises.length,\n    userCount: userGroupMembers.size,\n  });\n\n  return {\n    users: await transformUsers(\n      client,\n      userGroupMembers.values(),\n      options.logger,\n      options.loadUserPhotos,\n      options.transformer,\n    ),\n  };\n}\n\nexport async function readMicrosoftGraphOrganization(\n  client: MicrosoftGraphClient,\n  tenantId: string,\n  options?: { transformer?: OrganizationTransformer },\n): Promise<{\n  rootGroup?: GroupEntity; // With all relations empty\n}> {\n  // For now we expect a single root organization\n  const organization = await client.getOrganization(tenantId);\n  const transformer = options?.transformer ?? defaultOrganizationTransformer;\n  const rootGroup = await transformer(organization);\n\n  return { rootGroup };\n}\n\nexport async function readMicrosoftGraphGroups(\n  client: MicrosoftGraphClient,\n  tenantId: string,\n  options?: {\n    queryMode?: 'basic' | 'advanced';\n    groupExpand?: string;\n    groupFilter?: string;\n    groupSearch?: string;\n    groupSelect?: string[];\n    groupTransformer?: GroupTransformer;\n    organizationTransformer?: OrganizationTransformer;\n  },\n): Promise<{\n  groups: GroupEntity[]; // With all relations empty\n  rootGroup: GroupEntity | undefined; // With all relations empty\n  groupMember: Map<string, Set<string>>;\n  groupMemberOf: Map<string, Set<string>>;\n}> {\n  const groups: GroupEntity[] = [];\n  const groupMember: Map<string, Set<string>> = new Map();\n  const groupMemberOf: Map<string, Set<string>> = new Map();\n  const limiter = limiterFactory(10);\n\n  const { rootGroup } = await readMicrosoftGraphOrganization(client, tenantId, {\n    transformer: options?.organizationTransformer,\n  });\n  if (rootGroup) {\n    groupMember.set(rootGroup.metadata.name, new Set<string>());\n    groups.push(rootGroup);\n  }\n\n  const transformer = options?.groupTransformer ?? defaultGroupTransformer;\n  const promises: Promise<void>[] = [];\n\n  for await (const group of client.getGroups(\n    {\n      expand: options?.groupExpand,\n      filter: options?.groupFilter,\n      search: options?.groupSearch,\n      select: options?.groupSelect,\n      top: PAGE_SIZE,\n    },\n    options?.queryMode,\n  )) {\n    // Process all groups in parallel, otherwise it can take quite some time\n    promises.push(\n      limiter(async () => {\n        // TODO: Loading groups photos doesn't work right now as Microsoft Graph\n        // doesn't allows this yet: https://microsoftgraph.uservoice.com/forums/920506-microsoft-graph-feature-requests/suggestions/37884922-allow-application-to-set-or-update-a-group-s-photo\n        /* const groupPhoto = await client.getGroupPhotoWithSizeLimit(\n          group.id!,\n          // We are limiting the photo size, as groups with full resolution photos\n          // can make the Backstage API slow\n          120,\n        );*/\n\n        const entity = await transformer(group /* , groupPhoto*/);\n\n        if (!entity) {\n          return;\n        }\n\n        for await (const member of client.getGroupMembers(group.id!, {\n          top: PAGE_SIZE,\n        })) {\n          if (!member.id) {\n            continue;\n          }\n\n          if (member['@odata.type'] === '#microsoft.graph.user') {\n            ensureItem(groupMemberOf, member.id, group.id!);\n          }\n\n          if (member['@odata.type'] === '#microsoft.graph.group') {\n            ensureItem(groupMember, group.id!, member.id);\n          }\n        }\n\n        groups.push(entity);\n      }),\n    );\n  }\n\n  // Wait for all group members and photos to be loaded\n  await Promise.all(promises);\n\n  return {\n    groups,\n    rootGroup,\n    groupMember,\n    groupMemberOf,\n  };\n}\n\nexport function resolveRelations(\n  rootGroup: GroupEntity | undefined,\n  groups: GroupEntity[],\n  users: UserEntity[],\n  groupMember: Map<string, Set<string>>,\n  groupMemberOf: Map<string, Set<string>>,\n) {\n  // Build reference lookup tables, we reference them by the id the the graph\n  const groupMap: Map<string, GroupEntity> = new Map(); // by group-id or tenant-id\n\n  for (const group of groups) {\n    if (group.metadata.annotations![MICROSOFT_GRAPH_GROUP_ID_ANNOTATION]) {\n      groupMap.set(\n        group.metadata.annotations![MICROSOFT_GRAPH_GROUP_ID_ANNOTATION],\n        group,\n      );\n    }\n    if (group.metadata.annotations![MICROSOFT_GRAPH_TENANT_ID_ANNOTATION]) {\n      groupMap.set(\n        group.metadata.annotations![MICROSOFT_GRAPH_TENANT_ID_ANNOTATION],\n        group,\n      );\n    }\n  }\n\n  // Resolve all member relationships into the reverse direction\n  const parentGroups = new Map<string, Set<string>>();\n\n  groupMember.forEach((members, groupId) =>\n    members.forEach(m => ensureItem(parentGroups, m, groupId)),\n  );\n\n  // Make sure every group (except root) has at least one parent. If the parent is missing, add the root.\n  if (rootGroup) {\n    const tenantId =\n      rootGroup.metadata.annotations![MICROSOFT_GRAPH_TENANT_ID_ANNOTATION];\n\n    groups.forEach(group => {\n      const groupId =\n        group.metadata.annotations![MICROSOFT_GRAPH_GROUP_ID_ANNOTATION];\n\n      if (!groupId) {\n        return;\n      }\n\n      if (retrieveItems(parentGroups, groupId).size === 0) {\n        ensureItem(parentGroups, groupId, tenantId);\n        ensureItem(groupMember, tenantId, groupId);\n      }\n    });\n  }\n\n  groups.forEach(group => {\n    const id =\n      group.metadata.annotations![MICROSOFT_GRAPH_GROUP_ID_ANNOTATION] ??\n      group.metadata.annotations![MICROSOFT_GRAPH_TENANT_ID_ANNOTATION];\n\n    retrieveItems(groupMember, id).forEach(m => {\n      const childGroup = groupMap.get(m);\n      if (childGroup) {\n        group.spec.children.push(stringifyEntityRef(childGroup));\n      }\n    });\n\n    retrieveItems(parentGroups, id).forEach(p => {\n      const parentGroup = groupMap.get(p);\n      if (parentGroup) {\n        // TODO: Only having a single parent group might not match every companies model, but fine for now.\n        group.spec.parent = stringifyEntityRef(parentGroup);\n      }\n    });\n  });\n\n  // Make sure that all groups have proper parents and children\n  buildOrgHierarchy(groups);\n\n  // Set relations for all users\n  users.forEach(user => {\n    const id = user.metadata.annotations![MICROSOFT_GRAPH_USER_ID_ANNOTATION];\n\n    retrieveItems(groupMemberOf, id).forEach(p => {\n      const parentGroup = groupMap.get(p);\n      if (parentGroup) {\n        if (!user.spec.memberOf) {\n          user.spec.memberOf = [];\n        }\n        user.spec.memberOf.push(stringifyEntityRef(parentGroup));\n      }\n    });\n  });\n\n  // Make sure all transitive memberships are available\n  buildMemberOf(groups, users);\n}\n\n/**\n * Reads an entire org as Group and User entities.\n *\n * @public\n */\nexport async function readMicrosoftGraphOrg(\n  client: MicrosoftGraphClient,\n  tenantId: string,\n  options: {\n    userExpand?: string;\n    userFilter?: string;\n    userSelect?: string[];\n    loadUserPhotos?: boolean;\n    userGroupMemberSearch?: string;\n    userGroupMemberFilter?: string;\n    groupExpand?: string;\n    groupSearch?: string;\n    groupFilter?: string;\n    groupSelect?: string[];\n    queryMode?: 'basic' | 'advanced';\n    userTransformer?: UserTransformer;\n    groupTransformer?: GroupTransformer;\n    organizationTransformer?: OrganizationTransformer;\n    logger: LoggerService;\n  },\n): Promise<{ users: UserEntity[]; groups: GroupEntity[] }> {\n  let users: UserEntity[] = [];\n\n  if (options.userGroupMemberFilter || options.userGroupMemberSearch) {\n    const { users: usersInGroups } = await readMicrosoftGraphUsersInGroups(\n      client,\n      {\n        queryMode: options.queryMode,\n        userExpand: options.userExpand,\n        userFilter: options.userFilter,\n        userSelect: options.userSelect,\n        userGroupMemberFilter: options.userGroupMemberFilter,\n        userGroupMemberSearch: options.userGroupMemberSearch,\n        loadUserPhotos: options.loadUserPhotos,\n        transformer: options.userTransformer,\n        logger: options.logger,\n      },\n    );\n    users = usersInGroups;\n  } else {\n    const { users: usersWithFilter } = await readMicrosoftGraphUsers(client, {\n      queryMode: options.queryMode,\n      userExpand: options.userExpand,\n      userFilter: options.userFilter,\n      userSelect: options.userSelect,\n      loadUserPhotos: options.loadUserPhotos,\n      transformer: options.userTransformer,\n      logger: options.logger,\n    });\n    users = usersWithFilter;\n  }\n  const { groups, rootGroup, groupMember, groupMemberOf } =\n    await readMicrosoftGraphGroups(client, tenantId, {\n      queryMode: options.queryMode,\n      groupExpand: options.groupExpand,\n      groupFilter: options.groupFilter,\n      groupSearch: options.groupSearch,\n      groupSelect: options.groupSelect,\n      groupTransformer: options.groupTransformer,\n      organizationTransformer: options.organizationTransformer,\n    });\n\n  resolveRelations(rootGroup, groups, users, groupMember, groupMemberOf);\n  users.sort((a, b) => a.metadata.name.localeCompare(b.metadata.name));\n  groups.sort((a, b) => a.metadata.name.localeCompare(b.metadata.name));\n\n  return { users, groups };\n}\n\nasync function transformUsers(\n  client: MicrosoftGraphClient,\n  users: Iterable<MicrosoftGraph.User> | AsyncIterable<MicrosoftGraph.User>,\n  logger: LoggerService,\n  loadUserPhotos = true,\n  transformer?: UserTransformer,\n) {\n  const limiter = limiterFactory(10);\n\n  const resolvedTransformer = transformer ?? defaultUserTransformer;\n  const promises: Promise<void>[] = [];\n  const entities: UserEntity[] = [];\n\n  // Process all users in parallel, otherwise it can take quite some time\n  for await (const user of users) {\n    promises.push(\n      limiter(async () => {\n        let userPhoto;\n        try {\n          if (loadUserPhotos) {\n            userPhoto = await client.getUserPhotoWithSizeLimit(\n              user.id!,\n              // We are limiting the photo size, as users with full resolution photos\n              // can make the Backstage API slow\n              120,\n            );\n          }\n        } catch (e) {\n          logger.warn(`Unable to load user photo for`, {\n            user: user.id,\n            error: e,\n          });\n        }\n\n        const entity = await resolvedTransformer(user, userPhoto);\n\n        if (entity) {\n          entities.push(entity);\n        }\n      }),\n    );\n  }\n\n  // Wait for all users and photos to be downloaded\n  await Promise.all(promises);\n\n  logger.debug('Finished transforming users', {\n    microsoftUserCount: promises.length,\n    backstageUserCount: entities.length,\n  });\n  return entities;\n}\n\nfunction ensureItem(\n  target: Map<string, Set<string>>,\n  key: string,\n  value: string,\n) {\n  let set = target.get(key);\n  if (!set) {\n    set = new Set();\n    target.set(key, set);\n  }\n  set!.add(value);\n}\n\nfunction retrieveItems(\n  target: Map<string, Set<string>>,\n  key: string,\n): Set<string> {\n  return target.get(key) ?? new Set();\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PluginTaskScheduler, TaskRunner } from '@backstage/backend-tasks';\nimport {\n  ANNOTATION_LOCATION,\n  ANNOTATION_ORIGIN_LOCATION,\n  Entity,\n} from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport {\n  EntityProvider,\n  EntityProviderConnection,\n} from '@backstage/plugin-catalog-node';\nimport { merge } from 'lodash';\nimport * as uuid from 'uuid';\nimport {\n  GroupTransformer,\n  MICROSOFT_GRAPH_GROUP_ID_ANNOTATION,\n  MICROSOFT_GRAPH_TENANT_ID_ANNOTATION,\n  MICROSOFT_GRAPH_USER_ID_ANNOTATION,\n  MicrosoftGraphClient,\n  MicrosoftGraphProviderConfig,\n  ProviderConfigTransformer,\n  OrganizationTransformer,\n  readMicrosoftGraphConfig,\n  readMicrosoftGraphOrg,\n  UserTransformer,\n} from '../microsoftGraph';\nimport { readProviderConfigs } from '../microsoftGraph/config';\nimport { LoggerService } from '@backstage/backend-plugin-api';\n\n/**\n * Options for {@link MicrosoftGraphOrgEntityProvider}.\n *\n * @public\n */\nexport type MicrosoftGraphOrgEntityProviderOptions =\n  | MicrosoftGraphOrgEntityProviderLegacyOptions\n  | {\n      /**\n       * The logger to use.\n       */\n      logger: LoggerService;\n\n      /**\n       * The refresh schedule to use.\n       *\n       * @remarks\n       *\n       * If you pass in 'manual', you are responsible for calling the `read` method\n       * manually at some interval.\n       *\n       * But more commonly you will pass in the result of\n       * {@link @backstage/backend-tasks#PluginTaskScheduler.createScheduledTaskRunner}\n       * to enable automatic scheduling of tasks.\n       */\n      schedule?: 'manual' | TaskRunner;\n\n      /**\n       * Scheduler used to schedule refreshes based on\n       * the schedule config.\n       */\n      scheduler?: PluginTaskScheduler;\n\n      /**\n       * The function that transforms a user entry in msgraph to an entity.\n       * Optionally, you can pass separate transformers per provider ID.\n       */\n      userTransformer?: UserTransformer | Record<string, UserTransformer>;\n\n      /**\n       * The function that transforms a group entry in msgraph to an entity.\n       * Optionally, you can pass separate transformers per provider ID.\n       */\n      groupTransformer?: GroupTransformer | Record<string, GroupTransformer>;\n\n      /**\n       * The function that transforms an organization entry in msgraph to an entity.\n       * Optionally, you can pass separate transformers per provider ID.\n       */\n      organizationTransformer?:\n        | OrganizationTransformer\n        | Record<string, OrganizationTransformer>;\n\n      /**\n       * The function that transforms provider config dynamically.\n       */\n      providerConfigTransformer?:\n        | ProviderConfigTransformer\n        | Record<string, ProviderConfigTransformer>;\n    };\n\n/**\n * Legacy options for {@link MicrosoftGraphOrgEntityProvider}\n * based on `catalog.processors.microsoftGraphOrg`.\n *\n * @public\n * @deprecated This interface exists for backwards compatibility only and will be removed in the future.\n */\nexport interface MicrosoftGraphOrgEntityProviderLegacyOptions {\n  /**\n   * A unique, stable identifier for this provider.\n   *\n   * @example \"production\"\n   */\n  id: string;\n\n  /**\n   * The target that this provider should consume.\n   *\n   * Should exactly match the \"target\" field of one of the provider\n   * configuration entries.\n   */\n  target: string;\n\n  /**\n   * The logger to use.\n   */\n  logger: LoggerService;\n\n  /**\n   * The refresh schedule to use.\n   *\n   * @remarks\n   *\n   * If you pass in 'manual', you are responsible for calling the `read` method\n   * manually at some interval.\n   *\n   * But more commonly you will pass in the result of\n   * {@link @backstage/backend-tasks#PluginTaskScheduler.createScheduledTaskRunner}\n   * to enable automatic scheduling of tasks.\n   */\n  schedule: 'manual' | TaskRunner;\n\n  /**\n   * The function that transforms a user entry in msgraph to an entity.\n   */\n  userTransformer?: UserTransformer;\n\n  /**\n   * The function that transforms a group entry in msgraph to an entity.\n   */\n  groupTransformer?: GroupTransformer;\n\n  /**\n   * The function that transforms an organization entry in msgraph to an entity.\n   */\n  organizationTransformer?: OrganizationTransformer;\n\n  /**\n   *  The function that transforms provider config dynamically.\n   */\n  providerConfigTransformer?: ProviderConfigTransformer;\n}\n\n/**\n * Reads user and group entries out of Microsoft Graph, and provides them as\n * User and Group entities for the catalog.\n *\n * @public\n */\nexport class MicrosoftGraphOrgEntityProvider implements EntityProvider {\n  private connection?: EntityProviderConnection;\n  private scheduleFn?: () => Promise<void>;\n\n  static fromConfig(\n    configRoot: Config,\n    options: MicrosoftGraphOrgEntityProviderOptions,\n  ): MicrosoftGraphOrgEntityProvider[] {\n    if ('id' in options) {\n      return [\n        MicrosoftGraphOrgEntityProvider.fromLegacyConfig(configRoot, options),\n      ];\n    }\n\n    if (!options.schedule && !options.scheduler) {\n      throw new Error('Either schedule or scheduler must be provided.');\n    }\n\n    function getTransformer<T extends Function>(\n      id: string,\n      transformers?: T | Record<string, T>,\n    ): T | undefined {\n      if (['undefined', 'function'].includes(typeof transformers)) {\n        return transformers as T;\n      }\n\n      return (transformers as Record<string, T>)[id];\n    }\n\n    return readProviderConfigs(configRoot).map(providerConfig => {\n      if (!options.schedule && !providerConfig.schedule) {\n        throw new Error(\n          `No schedule provided neither via code nor config for MicrosoftGraphOrgEntityProvider:${providerConfig.id}.`,\n        );\n      }\n\n      const taskRunner =\n        options.schedule ??\n        options.scheduler!.createScheduledTaskRunner(providerConfig.schedule!);\n\n      const provider = new MicrosoftGraphOrgEntityProvider({\n        id: providerConfig.id,\n        provider: providerConfig,\n        logger: options.logger,\n        userTransformer: getTransformer(\n          providerConfig.id,\n          options.userTransformer,\n        ),\n        groupTransformer: getTransformer(\n          providerConfig.id,\n          options.groupTransformer,\n        ),\n        organizationTransformer: getTransformer(\n          providerConfig.id,\n          options.organizationTransformer,\n        ),\n        providerConfigTransformer: getTransformer(\n          providerConfig.id,\n          options.providerConfigTransformer,\n        ),\n      });\n\n      if (taskRunner !== 'manual') {\n        provider.schedule(taskRunner);\n      }\n\n      return provider;\n    });\n  }\n\n  /**\n   * @deprecated Exists for backwards compatibility only and will be removed in the future.\n   */\n  private static fromLegacyConfig(\n    configRoot: Config,\n    options: MicrosoftGraphOrgEntityProviderLegacyOptions,\n  ): MicrosoftGraphOrgEntityProvider {\n    options.logger.warn(\n      'Deprecated msgraph config \"catalog.processors.microsoftGraphOrg\" used. Use \"catalog.providers.microsoftGraphOrg\" instead. More info at https://github.com/backstage/backstage/blob/master/plugins/catalog-backend-module-msgraph/CHANGELOG.md#040-next1',\n    );\n    const config = configRoot.getOptionalConfig(\n      'catalog.processors.microsoftGraphOrg',\n    );\n    const providers = config ? readMicrosoftGraphConfig(config) : [];\n    const provider = providers.find(p => options.target.startsWith(p.target));\n\n    if (!provider) {\n      throw new Error(\n        `There is no Microsoft Graph Org provider that matches \"${options.target}\". Please add a configuration entry for it under \"catalog.processors.microsoftGraphOrg.providers\".`,\n      );\n    }\n\n    const logger = options.logger.child({\n      target: options.target,\n    });\n\n    const result = new MicrosoftGraphOrgEntityProvider({\n      id: options.id,\n      userTransformer: options.userTransformer,\n      groupTransformer: options.groupTransformer,\n      organizationTransformer: options.organizationTransformer,\n      providerConfigTransformer: options.providerConfigTransformer,\n      logger,\n      provider,\n    });\n\n    if (options.schedule !== 'manual') {\n      result.schedule(options.schedule);\n    }\n\n    return result;\n  }\n\n  constructor(\n    private options: {\n      id: string;\n      provider: MicrosoftGraphProviderConfig;\n      logger: LoggerService;\n      userTransformer?: UserTransformer;\n      groupTransformer?: GroupTransformer;\n      organizationTransformer?: OrganizationTransformer;\n      providerConfigTransformer?: ProviderConfigTransformer;\n    },\n  ) {}\n\n  /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.getProviderName} */\n  getProviderName() {\n    return `MicrosoftGraphOrgEntityProvider:${this.options.id}`;\n  }\n\n  /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.connect} */\n  async connect(connection: EntityProviderConnection) {\n    this.connection = connection;\n    await this.scheduleFn?.();\n  }\n\n  /**\n   * Runs one complete ingestion loop. Call this method regularly at some\n   * appropriate cadence.\n   */\n  async read(options?: { logger?: LoggerService }) {\n    if (!this.connection) {\n      throw new Error('Not initialized');\n    }\n\n    const logger = options?.logger ?? this.options.logger;\n    const provider = this.options.providerConfigTransformer\n      ? await this.options.providerConfigTransformer(this.options.provider)\n      : this.options.provider;\n    const { markReadComplete } = trackProgress(logger);\n    const client = MicrosoftGraphClient.create(this.options.provider);\n    const { users, groups } = await readMicrosoftGraphOrg(\n      client,\n      provider.tenantId,\n      {\n        userExpand: provider.userExpand,\n        userFilter: provider.userFilter,\n        userSelect: provider.userSelect,\n        loadUserPhotos: provider.loadUserPhotos,\n        userGroupMemberFilter: provider.userGroupMemberFilter,\n        userGroupMemberSearch: provider.userGroupMemberSearch,\n        groupExpand: provider.groupExpand,\n        groupFilter: provider.groupFilter,\n        groupSearch: provider.groupSearch,\n        groupSelect: provider.groupSelect,\n        queryMode: provider.queryMode,\n        groupTransformer: this.options.groupTransformer,\n        userTransformer: this.options.userTransformer,\n        organizationTransformer: this.options.organizationTransformer,\n        logger: logger,\n      },\n    );\n\n    const { markCommitComplete } = markReadComplete({ users, groups });\n\n    await this.connection.applyMutation({\n      type: 'full',\n      entities: [...users, ...groups].map(entity => ({\n        locationKey: `msgraph-org-provider:${this.options.id}`,\n        entity: withLocations(this.options.id, entity),\n      })),\n    });\n\n    markCommitComplete();\n  }\n\n  private schedule(taskRunner: TaskRunner) {\n    this.scheduleFn = async () => {\n      const id = `${this.getProviderName()}:refresh`;\n      await taskRunner.run({\n        id,\n        fn: async () => {\n          const logger = this.options.logger.child({\n            class: MicrosoftGraphOrgEntityProvider.prototype.constructor.name,\n            taskId: id,\n            taskInstanceId: uuid.v4(),\n          });\n\n          try {\n            await this.read({ logger });\n          } catch (error) {\n            logger.error(\n              `${this.getProviderName()} refresh failed, ${error}`,\n              error,\n            );\n          }\n        },\n      });\n    };\n  }\n}\n\n// Helps wrap the timing and logging behaviors\nfunction trackProgress(logger: LoggerService) {\n  let timestamp = Date.now();\n  let summary: string;\n\n  logger.info('Reading msgraph users and groups');\n\n  function markReadComplete(read: { users: unknown[]; groups: unknown[] }) {\n    summary = `${read.users.length} msgraph users and ${read.groups.length} msgraph groups`;\n    const readDuration = ((Date.now() - timestamp) / 1000).toFixed(1);\n    timestamp = Date.now();\n    logger.info(`Read ${summary} in ${readDuration} seconds. Committing...`);\n    return { markCommitComplete };\n  }\n\n  function markCommitComplete() {\n    const commitDuration = ((Date.now() - timestamp) / 1000).toFixed(1);\n    logger.info(`Committed ${summary} in ${commitDuration} seconds.`);\n  }\n\n  return { markReadComplete };\n}\n\n// Makes sure that emitted entities have a proper location based on their uuid\nexport function withLocations(providerId: string, entity: Entity): Entity {\n  const uid =\n    entity.metadata.annotations?.[MICROSOFT_GRAPH_USER_ID_ANNOTATION] ||\n    entity.metadata.annotations?.[MICROSOFT_GRAPH_GROUP_ID_ANNOTATION] ||\n    entity.metadata.annotations?.[MICROSOFT_GRAPH_TENANT_ID_ANNOTATION] ||\n    entity.metadata.name;\n  const location = `msgraph:${providerId}/${encodeURIComponent(uid)}`;\n  return merge(\n    {\n      metadata: {\n        annotations: {\n          [ANNOTATION_LOCATION]: location,\n          [ANNOTATION_ORIGIN_LOCATION]: location,\n        },\n      },\n    },\n    entity,\n  ) as Entity;\n}\n"],"names":["ClientSecretCredential","DefaultAzureCredential","qs","fetch","trimEnd","readTaskScheduleDefinitionFromConfig","limiterFactory","stringifyEntityRef","uuid","merge","ANNOTATION_LOCATION","ANNOTATION_ORIGIN_LOCATION"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/index.cjs.js b/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/index.cjs.js
index 8942c5b..9226f0c 100644
--- a/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/index.cjs.js
+++ b/node_modules/@backstage/plugin-catalog-backend-module-msgraph/dist/index.cjs.js
@@ -1,6 +1,6 @@
 'use strict';
 
-var MicrosoftGraphOrgEntityProvider = require('./cjs/MicrosoftGraphOrgEntityProvider-mdJJRFUn.cjs.js');
+var MicrosoftGraphOrgEntityProvider = require('./cjs/MicrosoftGraphOrgEntityProvider-BkGFhBQB.cjs.js');
 var pluginCatalogNode = require('@backstage/plugin-catalog-node');
 require('@backstage/catalog-model');
 require('lodash');
